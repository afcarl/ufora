/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#pragma once

#include "MemoryBlockId.hppml"
#include "MemoryViewId.hppml"

#include "../../core/containers/MapWithIndex.hpp"
#include "../../core/containers/TwoWaySetMap.hpp"
#include "../../core/math/IntegerRange.hppml"
#include "../../core/math/RangeToIntegerSequence.hppml"
#include "../../core/math/IntegerRanges.hppml"

class MemoryViewDefinition;

@type BlockOrViewId =
    -| View of MemoryViewId view
    -| Block of MemoryBlockId block
    ;
macro_defineCppmlComparisonOperators(BlockOrViewId);

//describes a single allocation zone. Zone memory is always page aligned
@type AllocationZone =
    //raw block data, with first byte of the block starting at 'byteOffset' inside the zone
    -| Block of MemoryBlockId block, int64_t byteOffset
    //a bigvec zone.
    -| View of MemoryViewId view
    ;
macro_defineCppmlComparisonOperators(AllocationZone);

//describes how a visible region of memory is mapped to an AllocationZone
@type RangeToZoneMapping =
    IntegerRange    byteRangeInObject,
    AllocationZone  zoneContainingData,
    IntegerRange    byteRangeInZone
{
public:
    RangeToZoneMapping expandedToZoneRange(IntegerRange rangeInZone) const
        {
        lassert(rangeInZone.contains(byteRangeInZone()));

        RangeToZoneMapping res = *this;

        res.byteRangeInObject().low() += rangeInZone.low() - res.byteRangeInZone().low();
        res.byteRangeInObject().high() += rangeInZone.high() - res.byteRangeInZone().high();

        res.byteRangeInZone() = rangeInZone;

        return res;
        }

    RangeToZoneMapping restrictedToObjectRange(IntegerRange rangeInObject) const
        {
        lassert(byteRangeInObject().contains(rangeInObject));

        return RangeToZoneMapping(
            rangeInObject,
            zoneContainingData(),
            byteRangeInZone().slice(rangeInObject - byteRangeInObject().low())
            );
        }

    RangeToZoneMapping restrictedToZoneRange(IntegerRange rangeInZone) const
        {
        lassert_dump(
            byteRangeInZone().contains(rangeInZone),
            "Expected " << prettyPrintString(byteRangeInZone())
                << " to fully contain " << prettyPrintString(rangeInZone)
            );

        return RangeToZoneMapping(
            byteRangeInObject().slice(rangeInZone - byteRangeInZone().low()),
            zoneContainingData(),
            rangeInZone
            );
        }
};

//describes how a part of an object is mapped into its original pages
@type ZoneToBlockMapping =
    IntegerRange byteRangeInZone,
    MemoryBlockId block,
    IntegerRange byteRangeInBlock
{
public:
    IntegerRange mapZoneSubrangeToBlock(IntegerRange zoneSubrange) const
        {
        lassert(byteRangeInZone().contains(zoneSubrange));
        return zoneSubrange - byteRangeInZone().low() + byteRangeInBlock().low();
        }
};

//represents a group of pages allocated to be the physical backing
//of a bigvec or a page
@type PhysicalMemoryAllocation =
    AllocationZone zone,
    IntegerRange byteRange
    ;

macro_defineCppmlComparisonOperators(PhysicalMemoryAllocation);


//decides how we map memory views to allocation zones
class AllocationZoneMapping {
public:
    AllocationZoneMapping(int64_t pageSize);

    void discardMemoryView(const MemoryViewId& id);

    void addMemoryView(const MemoryViewDefinition& layout);

    IntegerRange zeroPaddingBytesFor(PhysicalMemoryAllocation alloc);

    RangeToZoneMapping zoneMappingFor(const BlockOrViewId& object, IntegerRange byterange) const;

    const std::map<AllocationZone, long>& zonesActiveForBlock(const MemoryBlockId& block);

    void mapZoneRangeToBlockRanges(
                AllocationZone zone,
                IntegerRange byteRange,
                std::vector<ZoneToBlockMapping>& outRanges,
                IntegerRange& outBytesOfPaddingZeros
                );

    uint64_t roundUpToPageSize(uint64_t o) const;

    uint64_t roundDownToPageSize(uint64_t o) const;

    IntegerRange clipToPageSize(IntegerRange in) const;

    int64_t pageSize() const;

private:
    void addMemoryViewZone(MemoryViewId id, RangeToZoneMapping mapping);

    int64_t mPageSize;

    //these are all in bytecounts
    map<MemoryViewId, uint64_t> mMemoryViewBytecountMapping;

    map<MemoryViewId, map<int64_t, MemoryBlockByteRange> > mMemoryViewBlockRangeMapping; // Useful for mapZoneRangeToBlockRanges

    map<MemoryViewId, IntegerRanges<false> > mMemoryViewBlockBoundaries; // Useful for mapZoneRangeToBlockRanges

    map<MemoryViewId, IntegerRanges<false> > mMemoryViewZoneBoundaries; // Useful for zoneMappingFor

    map<pair<MemoryViewId, IntegerRange>, RangeToZoneMapping> mMemoryViewZoneMappings; // Useful for zoneMappingFor

    std::map<MemoryBlockId, std::map<AllocationZone, long> > mMemoryBlockZoneRefcounts;
};
