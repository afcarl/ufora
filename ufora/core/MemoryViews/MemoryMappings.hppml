/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#pragma once

#include "AllocationZoneMapping.hppml"
#include "PhysicalAllocations.hppml"

class MemoryMappings {
public:
    MemoryMappings(
                AllocationZoneMapping& inZoneMappings,
                PhysicalAllocations& inPhysicalAllocations,
                boost::function<bool (uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> inMapper,
                boost::function<bool (uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> inUnmapper
                );

    void removeAllMappingsFor(PhysicalMemoryAllocation alloc);

    //indicate that a thread is blocking on a memory block. The given zone should always be exactly one
    //physical page in an AllocationZone.
    void blockedThreadExists(
                BlockOrViewId object,
                RangeToZoneMapping zoneMapping
                );

    //indicate that to be able to instantiate a byte range, we'll actually need some memory block data
    void zoneNeeds(AllocationZone zone, IntegerRange byteRangeInZone, const std::vector<pair<MemoryBlockId, IntegerRange> >& inNeededBlockData);

    void blockDataProvided(MemoryBlockId block, IntegerRange range);

    void deallocatePhysicalMemory(PhysicalMemoryAllocation zone);

    void zoneIsNowMappable(AllocationZone zone, IntegerRange range);

    void extractZonesToTryToMap(std::vector<pair<AllocationZone, IntegerRange> >& outZones);

    bool hasZonesToTryToMap() const;

    bool byteIsMapped(BlockOrViewId object, int64_t byteOffset);

    bool zoneHasPendingMappings(AllocationZone zone) const;

private:
    void ensureRangeMapped(BlockOrViewId object, RangeToZoneMapping mapping);

    void mapByteRange(BlockOrViewId object, RangeToZoneMapping mapping);

    void mapByteRange(BlockOrViewId object, IntegerRange rangeInObject, PhysicalMemoryAllocation alloc, IntegerRange rangeInAlloc);

    AllocationZoneMapping& mZoneMappings;

    PhysicalAllocations& mPhysicalAllocations;

    boost::function<bool (uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> mMapper;

    boost::function<bool (uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> mUnmapper;

    //state machine for zones that want to wake up when block data is provided from the outside
    std::map<pair<AllocationZone, IntegerRange>, std::map<MemoryBlockId, IntegerRanges<true> > >  mZonesAwaitingBlockData;

    TwoWaySetMap<pair<AllocationZone, IntegerRange>, MemoryBlockId> mZonesAwaitingBlockDataBlocks;

    std::vector<pair<AllocationZone, IntegerRange> > mZonesToTryToMap;

    std::map<BlockOrViewId, IntegerRanges<true> > mBytesMapped;

    std::map<AllocationZone, IntegerRanges<true> > mZoneMappableRegions;

    //mappings we'd like to apply as soon as various copy operations complete
    std::map<AllocationZone, std::vector<pair<BlockOrViewId, RangeToZoneMapping> > > mPendingMappings;

    std::map<PhysicalMemoryAllocation, std::vector<pair<BlockOrViewId, IntegerRange> > > mMappings;
};
