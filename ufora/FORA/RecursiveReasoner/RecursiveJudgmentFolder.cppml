/***************************************************************************
    Copyright 2017 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "RecursiveJudgmentFolder.hppml"
#include "../Core/ClassMediator.hppml"
#include "../../core/containers/TwoWaySetMap.hpp"
#include "../../core/cppml/CPPMLVisit.hppml"
#include "../../core/cppml/RenameTransformer.hppml"

namespace {

@type RecursiveJudgmentPair = RecursiveJudgment j1, RecursiveJudgment j2;


//get rid of simple definitions in the recursive judgment that are only used in one
//place
RecursiveJudgment simplify(RecursiveJudgment in)
    {
    @match RecursiveJudgment(in)
        -| RecursiveScope(judgments, j) ->> {
            TwoWaySetMap<RecursiveJudgmentName, RecursiveJudgmentName> useMap;

            for (auto nameAndJudgments: judgments)
                CPPMLVisitor<>()
                    .down<RecursiveJudgment_NamedType>(
                        [&](const RecursiveJudgment_NamedType& in) {
                            useMap.insert(nameAndJudgments.first, in.name());
                            })
                    .visit(nameAndJudgments.second)
                    ;

            CPPMLVisitor<>()
                    .down<RecursiveJudgment_NamedType>(
                        [&](const RecursiveJudgment_NamedType& in) {
                            useMap.insert(RecursiveJudgmentName::Create("root"), in.name());
                            })
                    .visit(j);

            std::set<RecursiveJudgmentName> candidates;

            //defined types that are not used more than once are all candidates
            for (auto nameAndJudgments: judgments)
                if (useMap.getKeys(nameAndJudgments.first).size() <= 1)
                    candidates.insert(nameAndJudgments.first);

            ImmutableTreeMap<RecursiveJudgment, RecursiveJudgment> toInline;

            for (auto c: candidates)
                {   
                if (useMap.getKeys(c).size() == 0 || 
                        useMap.getKeys(c).size() == 1 && !useMap.contains(c,c))
                    {
                    toInline = toInline + RecursiveJudgment::Named(c) + *judgments[c];

                    std::set<RecursiveJudgmentName> usingThis = useMap.getKeys(c);
                    std::set<RecursiveJudgmentName> usedByThis = useMap.getValues(c);

                    useMap.dropKey(c);
                    useMap.dropValue(c);

                    for (auto u1: usingThis)
                        for (auto u2: usedByThis)
                            useMap.insert(u1, u2);
                    }
                }

            ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> toKeep;

            for (auto nameAndJudgments: judgments)
                if (!toInline.contains(RecursiveJudgment::Named(nameAndJudgments.first)))
                    toKeep = toKeep + nameAndJudgments.first + 
                        RenameTransformer<RecursiveJudgment>::rename(nameAndJudgments.second, toInline);

            RecursiveJudgment body = RenameTransformer<RecursiveJudgment>::rename(j, toInline);

            body = RecursiveJudgment::UnionIfSeveral(body.unpackUnion());
            
            if (toKeep.size())
                return RecursiveJudgment::RecursiveScope(toKeep, body);

            return body;
            }
    }


class FoldingContext {
public:
    ImmutableTreeSet<RecursiveJudgment> fold(RecursiveJudgment j)
        {
        static Type typeInt64 = Type::Integer(64, true);
        static Type typeUInt64 = Type::Integer(64, false);
        static Type typeBool = Type::Integer(1, false);
        static int64_t maxIntegerValue = 8;
        static int64_t maxTupleArity = 8;
        static int64_t maxClassTerms = 32;

        @match RecursiveJudgment(j)
            -| Empty() ->> { return emptyTreeSet(); }
            -| Union(values) ->> {
                ImmutableTreeSet<RecursiveJudgment> final;
                for (auto v: values)
                    final = final + fold(v);
                return final;
                }
            -| Named(n) ->> {
                return emptyTreeSet() + j;
                }
            -| Atom(Typed()) ->> {
                return emptyTreeSet() + j;
                }
            -| Atom(Valued(v)) ->> {
                if (v.type().isSymbol())
                    return emptyTreeSet() + j;
                if (v.type() == typeInt64 && *v.getInt64() >= -maxIntegerValue && *v.getInt64() <= maxIntegerValue)
                    return emptyTreeSet() + j;
                if (v.type() == typeBool)
                    return emptyTreeSet() + j;

                return emptyTreeSet() + RecursiveJudgment::Atom(JudgmentOnValueAtom::Typed(v.type()));
                }
            -| Class(classBody, jovs) ->> {
                ImmutableTreeVector<RecursiveJudgment> terms;
                for (long k = 0; k < jovs.size(); k++)
                    {
                    auto name = RecursiveJudgmentName::CreateCompound("Fold", classBody, std::min<int64_t>(k, maxClassTerms));

                    terms = terms + RecursiveJudgment::Named(name);

                    mNameMap[name] = mNameMap[name] + fold(jovs[k]);
                    }
                return emptyTreeSet() + RecursiveJudgment::Class(classBody, terms);
                }
            -| Tuple(jovs, names, extras) ->> {
                ImmutableTreeVector<RecursiveJudgment> mergedJovs;

                for (long k = 0; k < jovs.size(); k++)
                    {
                    RecursiveJudgmentName name;

                    if (names[k])
                        name = RecursiveJudgmentName::CreateCompound("Fold", "Tuple", *names[k]);
                    else
                        name = RecursiveJudgmentName::CreateCompound("Fold", "Tuple", k, std::min<int64_t>(jovs.size(), maxTupleArity));

                    mNameMap[name] = mNameMap[name] + fold(jovs[k]);

                    mergedJovs = mergedJovs + RecursiveJudgment::Named(name);
                    }

                RecursiveJudgment newExtras;
                if (!extras.isEmpty())
                    {
                    auto name = RecursiveJudgmentName::CreateCompound("Fold", "Tuple Extras");
                    mNameMap[name] = mNameMap[name] + fold(extras);

                    newExtras = RecursiveJudgment::Named(name);
                    }


                return emptyTreeSet() + RecursiveJudgment::Tuple(mergedJovs, names, newExtras)
                }
            -| Vector(j) ->> {
                return simpleFold("Vector", j);
                }
            -| MutableVector(j) ->> {
                return simpleFold("MutableVector", j);
                }
            -| Dictionary(j) ->> {
                return simpleFold("Dictionary", j);
                }
            -| Alternative(s, j) ->> {
                return simpleFold("Alternative", s, j);
                }
            -| RecursiveScope(namedJmts, j) ->> {
                for (auto nameAndJmt: namedJmts)
                    {
                    lassert(isFoldName(nameAndJmt.first));
                    mNameMap[nameAndJmt.first] = mNameMap[nameAndJmt.first] + 
                        fold(nameAndJmt.second);
                    }

                return fold(j);
                }
            -| Unknown() ->> {
                return emptyTreeSet() + j;
                }
        }

    static bool isFoldName(RecursiveJudgmentName name)
        {
        @match RecursiveJudgmentName(name)
            -| Compound(names) ->> {
                if (names.size() && names[0].isString() && names[0].getString().name() == "Fold")
                    return true;
                }
            -| _ ->> {}

        return false;
        }

    ImmutableTreeSet<RecursiveJudgment> simpleFold(std::string kind, RecursiveJudgment jmt)
        {
        auto name = RecursiveJudgmentName::CreateCompound("Fold", kind);
        mNameMap[name] = mNameMap[name] + fold(jmt);
        return emptyTreeSet() + RecursiveJudgment::Vector(RecursiveJudgment::Named(name));
        }

    ImmutableTreeSet<RecursiveJudgment> simpleFold(std::string kind, Symbol sym, RecursiveJudgment jmt)
        {
        auto name = RecursiveJudgmentName::CreateCompound("Fold", kind, sym);
        mNameMap[name] = mNameMap[name] + fold(jmt);
        return emptyTreeSet() + RecursiveJudgment::Vector(RecursiveJudgment::Named(name));
        }

    ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> judgmentMap() const
        {
        ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> judgments;

        for (auto& nameAndJudgments: mNameMap)
            judgments = judgments + nameAndJudgments.first + 
                RecursiveJudgment::UnionIfSeveral(
                    nameAndJudgments.second 
                        //during folding, we can end up with the tautology 'T=T | ...'
                        //embedded in the recursion - we just remove it
                        - RecursiveJudgment::Named(nameAndJudgments.first)
                    );

        return judgments;
        }

private:
    map<RecursiveJudgmentName, ImmutableTreeSet<RecursiveJudgment> > mNameMap;
};

}

RecursiveJudgment foldRecursiveJudgments(RecursiveJudgment j1, RecursiveJudgment j2)
    {
    @match RecursiveJudgmentPair(RecursiveJudgmentPair(j1, j2))
        -| (Empty(), _) ->> { return j2; }
        -| (_, Empty()) ->> { return j1; }
        -| (Atom(a1), Atom(a2)) ->> { 
            if (j1 == j2) 
                return j1; 
            }
        -| (Tuple(jovs, names, extras), Tuple(jovs2, names2, extras2)) ->> {
            if (names == names2 && extras.isEmpty() && extras2.isEmpty())
                {
                lassert_dump(jovs.size() == jovs2.size(), prettyPrintString(j1) << " and " << prettyPrintString(j2));

                return RecursiveJudgment::Tuple(
                    mapRange(jovs.size(), [&](long k) { 
                        lassert(k < jovs.size());
                        return foldRecursiveJudgments(jovs[k], jovs2[k]);
                        }),
                    names,
                    extras
                    );
                }
            }
        -| (Class(classBody1, jovs1), Class(classBody2, jovs2)) ->> {
            if (classBody1 == classBody2 && jovs1.size() == jovs2.size())
                return RecursiveJudgment::Class(
                    classBody1,
                    mapRange(jovs1.size(), [&](long k) { 
                        return foldRecursiveJudgments(jovs1[k], jovs2[k]);
                        })
                    );
            }
        -| _ ->> {}

    ImmutableTreeSet<RecursiveJudgment> used;

    FoldingContext context;

    used = used + context.fold(j1);
    used = used + context.fold(j2);

    ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> judgments = context.judgmentMap();

    return simplify(
        RecursiveJudgment::RecursiveScope(
            judgments, 
            RecursiveJudgment::Union(used)
            )
        );
    }
