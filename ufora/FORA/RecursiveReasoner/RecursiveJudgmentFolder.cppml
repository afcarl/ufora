/***************************************************************************
    Copyright 2017 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "RecursiveJudgmentFolder.hppml"

namespace {

@type RecursiveJudgmentPair = RecursiveJudgment j1, RecursiveJudgment j2;

class FoldingContext {
public:
    ImmutableTreeSet<RecursiveJudgment> fold(RecursiveJudgment j)
        {
        static Type typeInt64 = Type::Integer(64, true);
        static Type typeUInt64 = Type::Integer(64, false);
        static Type typeBool = Type::Integer(1, false);
        static int64_t maxIntegerValue = 8;
        static int64_t maxTupleArity = 8;
        static int64_t maxClassTerms = 32;

        @match RecursiveJudgment(j)
            -| Empty() ->> { return emptyTreeSet(); }
            -| Union(values) ->> {
                ImmutableTreeSet<RecursiveJudgment> final;
                for (auto v: values)
                    final = final + fold(v);
                return final;
                }
            -| Named(n) ->> {
                return emptyTreeSet() + j;
                }
            -| Atom(Typed()) ->> {
                return emptyTreeSet() + j;
                }
            -| Atom(Valued(v)) ->> {
                if (v.type().isSymbol())
                    return emptyTreeSet() + j;
                if (v.type() == typeInt64 && *v.getInt64() >= -maxIntegerValue && v.getInt64() <= maxIntegerValue)
                    return emptyTreeSet() + j;
                if (v.type() == typeBool)
                    return emptyTreeSet() + j;

                return emptyTreeSet() + RecursiveJudgment::Atom(JudgmentOnValueAtom::Typed(v.type()));
                }
            -| Class(classBody, jovs) ->> {
                ImmutableTreeVector<RecursiveJudgment> terms;
                for (long k = 0; k < jovs.size(); k++)
                    {
                    auto name = RecursiveJudgmentName::Create("Fold", classBody, std::min<int64_t>(k, maxClassTerms));

                    terms = terms + RecursiveJudgment::Named(name);

                    mNameMap[name] = mNameMap[name] + fold(jovs[k]);
                    }
                return RecursiveJudgment::Class(classBody, terms);
                }
            -| Tuple(jovs, names, extras) ->> {
                ImmutableTreeVector<RecursiveJudgment> mergedJovs;

                for (long k = 0; k < jovs.size(); k++)
                    {
                    RecursiveJudgmentName name;

                    if (names[k])
                        name = RecursiveJudgmentName::Create("Fold", "Tuple", *names[k]);
                    else
                        name = RecursiveJudgmentName::Create("Fold", "Tuple", k, std::min<int64_t>(k, maxTupleArity));

                    mNameMap[name] = mNameMap[name] + fold(jovs[k]);

                    mergedJovs = mergedJovs + RecursiveJudgment::Named(name);
                    }

                RecursiveJudgment newExtras;
                if (!extras.isEmpty())
                    {
                    auto name = RecursiveJudgmentName::Create("Fold", "Tuple Extras");
                    mNameMap[name] = mNameMap[name] + fold(extras);
                    }


                return RecursiveJudgment::Tuple(mergedJovs, names, newExtras)
                }
        }

    ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> judgmentMap() const
        {
        ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> judgments;

        for (auto& nameAndJudgments: mNameMap)
            if (nameAndJudgments.second.size() == 1)
                judgments = judgments + nameAndJudgments.first + 
                    RecursiveJudgment::UnionIfSeveral(nameAndJudgments.second);

        return judgments;
        }

private:
    map<RecursiveJudgmentName, ImmutableTreeSet<RecursiveJudgment> > mNameMap;
};

}

RecursiveJudgment foldRecursiveJudgments(RecursiveJudgment j1, RecursiveJudgment j2)
    {
    //common structural elements can be preserved
    @match RecursiveJudgmentPair(RecursiveJudgmentPair(j1, j2))
        -| (Empty(), _) ->> { return j2; }
        -| (_, Empty()) ->> { return j1; }
        -| (Atom(a1), Atom(a2)) ->> { 
            if (a1 == a2) 
                return j1; 
            }
        -| (Tuple(jovs, names, extras), Tuple(jovs2, names2, extras2)) ->> {
            if (names == names2 && extras.isEmpty() && extras2.isEmpty())
                return RecursiveJudgment::Tuple(
                    mapRange(jovs.size(), [&](long k) { 
                        return foldRecursiveJudgments(jovs[k], jovs2[k]);
                        }),
                    names,
                    extras
                    );
            }
        -| (Class(classBody1, jovs1), Class(classBody2, jovs2)) ->> {
            if (classBody1 == classBody2 && jovs1.size() == jovs2.size())
                return RecursiveJudgment::Class(
                    classBody1,
                    mapRange(jovs1.size(), [&](long k) { 
                        return foldRecursiveJudgments(jovs[k], jovs2[k]);
                        })
                    );
            }
        -| _ ->> {}

    ImmutableTreeSet<RecursiveJudgment> used;

    FoldingContext context;

    used = used + context.fold(j1);
    used = used + context.fold(j2);

    ImmutableTreeSet<RecursiveJudgmentName, RecursiveJudgment> judgments = context.judgmentMap();

    return RecursiveJudgment::RecursiveScope(
        judgments, 
        RecursiveJudgment::Union(
            mapITV(used, [&](RecursiveJudgmentName nm) { return RecursiveJudgment::Named(nm); })
            )
        );
    }