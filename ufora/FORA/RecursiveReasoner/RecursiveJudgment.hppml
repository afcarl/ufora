/***************************************************************************
    Copyright 2017 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/
#pragma once

#include "../Judgment/JudgmentOnValue.hppml"
#include "RecursiveJudgmentName.hppml"

//describes a set of FORA values
@type RecursiveJudgment = 
    -| Empty of ()
    -| Atom of JudgmentOnValueAtom jov
    -| Tuple of 
        ImmutableTreeVector<RecursiveJudgment> jovs, 
        ImmutableTreeVector<Nullable<Symbol> > names,
        RecursiveJudgment extras
    -| Class of 
        ClassBody classBody,
        ImmutableTreeVector<RecursiveJudgment> jov
    -| Vector of RecursiveJudgment jov
    -| MutableVector of RecursiveJudgment jov
    -| Dictionary of RecursiveJudgment keyValueJov
    -| Alternative of Symbol name, RecursiveJudgment value
    -| Union of ImmutableTreeSet<RecursiveJudgment> jovs
    -| Named of RecursiveJudgmentName name
    -| RecursiveScope of 
        ImmutableTreeMap<RecursiveJudgmentName, RecursiveJudgment> namedJudgments,
        RecursiveJudgment jov
    -| Unknown of ()
with
    hash_type hash = (hashValue(*this))
{
public:
    template<class T>
    static RecursiveJudgment UnionIfSeveral(T judgments)
        {
        ImmutableTreeSet<RecursiveJudgment> judgmentsVec;
        for (auto v: judgments)
            judgmentsVec = judgmentsVec + v;

        if (judgmentsVec.size() == 0)
            return RecursiveJudgment::Empty();
        if (judgmentsVec.size() == 1)
            return judgmentsVec[0];
        return RecursiveJudgment::Union(judgmentsVec);        
        }
};

macro_defineCppmlComparisonOperators(RecursiveJudgment)
macro_defineMemberHashFunction(RecursiveJudgment)
