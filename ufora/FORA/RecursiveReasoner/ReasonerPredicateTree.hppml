/***************************************************************************
    Copyright 2017 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/
#pragma once

#include "../Judgment/JudgmentOnValue.hppml"
#include "ReasonerPredicate.hppml"
#include "ReasonerPredicateResponse.hppml"

template<class leaf_type>
class ReasonerPredicateTree {
public:
    ReasonerPredicateTree()
        {
        mLeafValue.reset(new leaf_type());
        }

    //convert from leaf to predicate
    void setPredicate(ReasonerPredicate inPredicate)
        {
        lassert(!mPredicate);

        mLeafValue.reset();
        mPredicate = inPredicate;
        }

    const Nullable<ReasonerPredicate>& getPredicate() const
        {
        return mPredicate;
        }

    leaf_type& getLeaf()
        {
        lassert(mLeafValue);
        return *mLeafValue;
        }

    const leaf_type& getLeaf() const
        {
        lassert(mLeafValue);
        return *mLeafValue;
        }

    const map<ReasonerPredicateResponse, ReasonerPredicateTree<leaf_type> >& getResponses() const
        {
        return mResponses;
        }

    bool hasResponse(ReasonerPredicateResponse response)
        {
        return mResponses.find(response) != mResponses.end();
        }

    ReasonerPredicateTree<leaf_type>& getSubtree(ReasonerPredicateResponse response)
        {
        return mResponses[response];
        }

    ReasonerPredicateTree<leaf_type>& followPath(ImmutableTreeVector<ReasonerPredicateResponse> path, long index = 0)
        {
        if (path.size() == index || mLeafValue)
            return *this;

        auto it = mResponses.find(path[index]);
        lassert(it != mResponses.end());

        return it->second.followPath(path, index+1);
        }

    //visit each leaf in the predicate tree that matches the given judgments.
    //note that because the judgments may have unions, we may visit several leaves,
    //which is why the callback has to have judgments as an argument
    void visitLeaves(
                ImmutableTreeVector<RecursiveJudgment> judgments, 
                std::function<void (ImmutableTreeVector<RecursiveJudgment>, ImmutableTreeVector<ReasonerPredicateResponse>, leaf_type&)> visitor
                )
        {
        lassert(mLeafValue);
        visitor(judgments, emptyTreeVec(), *mLeafValue);
        }

private:
    Nullable<ReasonerPredicate> mPredicate;

    //only one of these may be populated
    map<ReasonerPredicateResponse, ReasonerPredicateTree<leaf_type> > mResponses;

    boost::shared_ptr<leaf_type> mLeafValue;
};
