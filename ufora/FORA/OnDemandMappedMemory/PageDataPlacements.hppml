/***************************************************************************
    Copyright 2016 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "AllocationZoneMapping.hppml"
#include "PhysicalAllocations.hppml"
#include "MemoryMappings.hppml"

/**************

This class provides a single-threaded implementation of a memory storage
and mapping services.

Clients are expected to provide data in the form of byte ranges associated with
Fora::PageIds, and then to access that data via pointers. The PageDataPlacements
infrastructure is responsible for populating that data while maintaining some invariants,
which include 
    a limit on the number of physical bytes above the actual bytes given to the object
    a limit on the number of memory mappings. (not implemented yet)
    a limit on the number of physical allocations. (not implemented yet)

The PageDataPlacements class is single-threaded. Callbacks are executed on
the same thread as the caller. Memory copy operations (which are expensive)
get queued in a task list. Clients are expected to call 'extractTask', execute
the task, and call 'taskCompleted' to flush the task queue after interacting
with the object. Tasks (which are just memory copies) can be executed in parallel.

***************/

@type AllocationToPageMapping = 
    IntegerRange byteRangeInAlloc,
    Fora::PageId page,
    IntegerRange byteRangeInPage
    ;

@type DataCopyTask = 
    uint8_t* dest,
    uint8_t* source,
    Nullable<PhysicalMemoryAllocation> destAlloc,
    Nullable<PhysicalMemoryAllocation> sourceAlloc,
    int64_t bytecount
{
public:
    void copy()
        {
        memcpy(dest(), source(), bytecount());
        }
};

class PageDataPlacements {
public:
    PageDataPlacements(
                int64_t inOsPageSize,
                //a set of callbacks that will be called synchronously during method invocation on
                //this class.
                boost::function<uint8_t* (PhysicalMemoryAllocation alloc)> inAllocator,
                boost::function<void (PhysicalMemoryAllocation alloc, uint8_t*)> inDeallocator,
                boost::function<bool (uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> inMapper,
                boost::function<bool (uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> inUnmapper,
                boost::function<void (Fora::PageId page, IntegerRange bytecountRange)> inRequestPageDataFromExternal,
                //maximum number of physical memory bytes to allocate above actual byte storage given to us
                int64_t maxExcessBytes,
                //this is a crappy proxy for limiting the number of allocations that really just
                //ensures that we don't have too many one-os-page allocs used to back bigvecs.
                int64_t maxBigvecAllocations
                );

    //is this object/element offset validly mapped?
    bool byteIsMapped(BigvecOrPageId mapping, int64_t byteOffset);

    //indicate that a thread is blocked reading this data. If the value is already mapped,
    //we disregard it.
    void markThreadBlockedOn(BigvecOrPageId mapping, int64_t byteOffset);

    void tryToConstructZone(AllocationZone zone, IntegerRange byteRangeInZone);

    //given a mapping and a byte offset in the mapping, what is the object and relative byte-offset it corresponds to?
    Nullable<pair<BigvecOrPageId, int64_t> > translateMappingAddress(uint8_t* mappingBase, uint64_t offsetInMapping);

    //describe a bigvec to us. This must be called before 'setMappableAddress' for the associated
    //bigvec can be called.
    void addBigVecPageLayout(const TypedFora::Abi::BigVectorPageLayout& layout);

    //we've produced a memory-mapping to 'target'
    void setMappableAddress(
                BigvecOrPageId target, 
                uint8_t* address, 
                uint64_t bytecount
                );

    //get the base address for a given target, or nullptr if none exists. 
    //this must have been provided by calling 'setMappableAddress'
    uint8_t* getMappableAddress(BigvecOrPageId target);

    //get the base address for a physical allocation. This address can be directly
    //written to.
    uint8_t* getWriteableAddress(PhysicalMemoryAllocation allocation);

    //drop the mapping target and clear all mappings. If this is a bigvec mapping,
    //then we drop the bigvec page layout as well.
    void dropMappingTarget(BigvecOrPageId target);

    //mark all the data associated with this page for deletion.
    //data will be released by the time the task queue is flushed.
    void dropAllDataForPage(const Fora::PageId& inPage);

    //get a memory copy task from the queue. Clients are expected
    //to flush this queue after calling 'markThreadBlockedOn',
    //allocatePageData, or dropAllDataForPage
    Nullable<DataCopyTask> extractTask();

    //indicates that some requested data was copied
    void taskComplete(DataCopyTask task);

    //add some new data from the outside. Clients are expected to 
    //flush all outstanding memory copy tasks from the system before 
    //'addr' may be released.
    bool allocatePageData(
                    const Fora::PageId& inPage, 
                    IntegerRange byteRange,
                    uint8_t* addr
                    );

private:
    //deallocate all memory associated with this allocation zone and clear
    //all associated mappings. No copy or pending maps can be outstanding on this.
    void completelyRemoveZone(AllocationZone zone);

    //deallocate this physical allocation.
    void completelyRemovePhysicalAlloc(PhysicalMemoryAllocation alloc);

    //after all copy and block operations, we call this function, which synchronously schedules any data
    //rebalancing operations
    void releaseMemoryIfNecessary();

    //release any bigvec mappings we have too many.
    void releaseBigvecsIfNecessary();

    //if we have too much data allocated, loop over all pages and consolidate
    //all of their data into a single AllocationZone.
    void consolidatePagesIfNecessary();

    //create PhysicalMemoryAllocations to back this data, making sure not to
    //double allocate any ranges.
    void ensurePhysicalBackingFor(
                const AllocationZone& inZone, 
                IntegerRange bytes
                );
    

    //the data required to populate 'byteRangeInZone' is present in the class, so now
    //schedule whatever is necessary to actually do the mapping.
    void scheduleNecessaryTasksForMapping(AllocationZone zone, IntegerRange byteRangeInZone);
    
    //schedule this data copy task, and add refcounts to the relevant zones.
    void scheduleTask(DataCopyTask task);

    IntegerRange pageContainingByteOffset(int64_t byteOffset);

    IntegerRange expandRangeToPageSize(IntegerRange byteRange);

    //populate the data for 'alloc' from some data somewhere. We assume that the data for the
    //relevant page mapping exists in the system and that we just need to find it.
    void scheduleCopyTask(PhysicalMemoryAllocation alloc, AllocationToPageMapping zonePageMapping);

    //populate the data for 'zone' from some data somewhere. We assume that the relevant page data
    //exists somewhere in some zone and that we just need to find it.
    void scheduleCopyTask(AllocationZone zone, ZoneToPageMapping zonePageMapping);

    //ensure that all data in 'sourceZone' that's not in 'destZone' gets there. When these
    //copy operations are complete, we will be able to completely remove 'sourceZone'
    bool scheduleCopyAllDataBetweenZones(AllocationZone sourceZone, AllocationZone destZone);

    int64_t mMaxExcessBytes;

    int64_t mMaxBigvecAllocations;

    int64_t mPageSize;

    //for each page, what values do we have actual definitions for somewhere
    int64_t mTotalBytesOfPageDataHeld;

    map<Fora::PageId, int64_t> mPerPageBytesHeld;

    map<Fora::PageId, IntegerRanges<true> > mPageDataBytecountRangesDefined;

    map<Fora::PageId, IntegerRanges<true> > mPageDataBytecountRangesDefinedOrRequested;

    //for each allocation, which ranges actually have values copied in?
    map<PhysicalMemoryAllocation, IntegerRanges<true> > mPhysicalMemoryBytecountRangesPopulated;

    map<AllocationZone, IntegerRanges<true> > mZoneBytecountRangesPopulated;

    map<AllocationZone, IntegerRanges<true> > mZoneBytecountRangesPopulatedOrPending;

    std::deque<DataCopyTask> mTasks;

    boost::function<void (Fora::PageId page, IntegerRange bytecountRange)> mBroadcastFunc;

    AllocationZoneMapping mAllocationZoneMapping;

    PhysicalAllocations mPhysicalAllocations;

    MemoryMappings mMemoryMappings;
};
