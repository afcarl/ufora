/***************************************************************************
    Copyright 2016 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "AllocationZoneMapping.hppml"
#include "PhysicalAllocations.hppml"
#include "MemoryMappings.hppml"

/**************

This class tracks the relationship between blocks of physical memory we've allocated
in shared memory pools, the data we have placed in them, and the mappings we've applied.

This class takes care of several things:
    * we need to keep track of which physical memory holds what data currently
    * we need to be able to tell in what locations the vector data we've already
        placed lives so we can get it back if need be.
    * when new vector data shows up, we need to figure out an ideal place to store it.
        this means looping over the various bigvecs that could hold it and seeing if
        we have storage allocated already for it.
    * when we want to map data for an address, we want to see if we already have storage
        for mappable for that page. if we can map it directly we do it immediately, but we may
        need to make an extra copy of the data.

***************/


@type AllocationToPageMapping = 
    IntegerRange byteRangeInAlloc,
    Fora::PageId page,
    IntegerRange byteRangeInPage
    ;

@type DataCopyTask = 
    uint8_t* dest,
    uint8_t* source,
    Nullable<PhysicalMemoryAllocation> destAlloc,
    Nullable<PhysicalMemoryAllocation> sourceAlloc,
    int64_t bytecount
{
public:
    void copy()
        {
        memcpy(dest(), source(), bytecount());
        }
};

class PageDataPlacements {
public:
    PageDataPlacements(
                int64_t inPageSize,
                boost::function<uint8_t* (PhysicalMemoryAllocation alloc)> inAllocator,
                boost::function<void (PhysicalMemoryAllocation alloc, uint8_t*)> inDeallocator,
                boost::function<bool (uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> inMapper,
                boost::function<bool (uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount)> inUnmapper,
                boost::function<void (Fora::PageId page, IntegerRange bytecountRange)> inBroadcaster,
                int64_t maxExcessBytes,
                int64_t maxBigvecAllocations
                );

    //is this object/element offset validly mapped?
    bool byteIsMapped(BigvecOrPageId mapping, int64_t byteOffset);

    //indicate that a thread is blocked reading this data. If the value is already mapped,
    //we disregard it.
    void markThreadBlockedOn(BigvecOrPageId mapping, int64_t byteOffset);

    void tryToConstructZone(AllocationZone zone, IntegerRange byteRangeInZone);

    //given a mapping and a byte offset in the mapping, what is the object and relative byte-offset it corresponds to?
    Nullable<pair<BigvecOrPageId, int64_t> > translateMappingAddress(uint8_t* mappingBase, uint64_t offsetInMapping);

    void addBigVecPageLayout(const TypedFora::Abi::BigVectorPageLayout& layout);

    //we've produced a memory-mapping to 'target'
    void setMappableAddress(
                BigvecOrPageId target, 
                uint8_t* address, 
                uint64_t bytecount
                );

    //get the base address for a given target, or nullptr if none exists
    uint8_t* getMappableAddress(BigvecOrPageId target);

    uint8_t* getWriteableAddress(PhysicalMemoryAllocation allocation);

    //drop the mapping target and mark all physical memory that's mapped to it as unmapped.
    void dropMappingTarget(BigvecOrPageId target);

    //indicates that some requested data was copied
    void taskComplete(DataCopyTask task);

    //get a list of all of the page placements
    void dropAllDataForPage(const Fora::PageId& inPage);

    Nullable<DataCopyTask> extractTask();

    //add some new data from the outside. Clients are expected to 
    //flush all outstanding memory copy tasks from the system before 
    //addr may be released.
    bool allocatePageData(
                    const Fora::PageId& inPage, 
                    IntegerRange byteRange,
                    uint8_t* addr
                    );

private:
    void completelyRemoveZone(AllocationZone zone);

    void completelyRemovePhysicalAlloc(PhysicalMemoryAllocation alloc);

    //after all copy and block operations, we call this function, which synchronously schedules any data
    void releaseMemoryIfNecessary();

    void releaseBigvecsIfNecessary();

    void consolidatePagesIfNecessary();

    //we wrote some page data into a block of physical memory and need to remember that that
    //data is populated
    void pageDataPlacedInPhysicalMemory(Fora::PageId page, IntegerSequence bytesWithinPage, PhysicalMemoryAllocation allocation, IntegerRange bytesWithinPhysical);

    void ensurePhysicalBackingFor(
                const AllocationZone& inZone, 
                IntegerRange bytes
                );
    
    void scheduleNecessaryTasksForMapping(AllocationZone zone, IntegerRange byteRangeInZone);
    
    void scheduleTask(DataCopyTask task);

    IntegerRange pageContainingByteOffset(int64_t byteOffset);

    IntegerRange expandRangeToPageSize(IntegerRange byteRange, int64_t pagesPerBlock);

    //populate the data for 'AllocationZone' from some data somewhere
    void scheduleCopyTask(PhysicalMemoryAllocation zone, AllocationToPageMapping zonePageMapping);

    //populate the data for 'AllocationZone' from some data somewhere
    void scheduleCopyTask(AllocationZone zone, ZoneToPageMapping zonePageMapping);

    bool scheduleCopyAllDataBetweenZones(AllocationZone sourceZone, AllocationZone destZone);

    int64_t mMaxExcessBytes;

    int64_t mMaxBigvecAllocations;

    int64_t mPageSize;

    //for each page, what values do we have actual definitions for somewhere
    int64_t mTotalBytesOfPageDataHeld;

    map<Fora::PageId, int64_t> mPerPageBytesHeld;

    map<Fora::PageId, IntegerRanges<true> > mPageDataBytecountRangesDefined;

    map<Fora::PageId, IntegerRanges<true> > mPageDataBytecountRangesDefinedOrRequested;

    //for each allocation, which ranges actually have values copied in?
    map<PhysicalMemoryAllocation, IntegerRanges<true> > mPhysicalMemoryBytecountRangesPopulated;

    map<AllocationZone, IntegerRanges<true> > mZoneBytecountRangesPopulated;

    map<AllocationZone, IntegerRanges<true> > mZoneBytecountRangesPopulatedOrPending;

    std::deque<DataCopyTask> mTasks;

    boost::function<void (Fora::PageId page, IntegerRange bytecountRange)> mBroadcastFunc;

    AllocationZoneMapping mAllocationZoneMapping;

    PhysicalAllocations mPhysicalAllocations;

    MemoryMappings mMemoryMappings;
};
