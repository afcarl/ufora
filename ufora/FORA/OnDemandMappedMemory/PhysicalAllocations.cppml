/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "PhysicalAllocations.hppml"

PhysicalAllocations::PhysicalAllocations(
            boost::function<uint8_t* (PhysicalMemoryAllocation alloc)> inAllocator,
            boost::function<void (PhysicalMemoryAllocation alloc, uint8_t*)> inDeallocator
            ) :
        mAllocateFunc(inAllocator),
        mDeallocateFunc(inDeallocator),
        mTotalBytesMapped(0),
        mIncreasingIndex(0)
    {
    }

Nullable<PhysicalMemoryAllocation> PhysicalAllocations::allocForAddress(uint8_t* addr) const
    {
    auto nRng = mPhysicalMemoryAddressesAsRanges.rangeContaining((int64_t)addr);
    if (!nRng)
        return null();

    const auto& keys = mPhysicalMemoryAddresses.getKeys((uint8_t*)nRng->low());
    lassert(keys.size() == 1);

    return null() << *keys.begin();
    }

IntegerRanges<false>& PhysicalAllocations::allocationsForZone(AllocationZone zone)
    {
    return mZoneBytecountRangesPhysicallyAllocated[zone];
    }

uint8_t* PhysicalAllocations::addressForAllocation(PhysicalMemoryAllocation alloc)
    {
    return mPhysicalMemoryAddresses.getValue(alloc);
    }

int64_t PhysicalAllocations::countOfMemoryViewAllocs() const
    {
    return mMemoryViewAllocationOrder.size();
    }

Nullable<PhysicalMemoryAllocation> PhysicalAllocations::oldestMemoryViewAlloc()
    {
    if (!mMemoryViewAllocationOrder.size())
        return null();

    const auto& keys = mMemoryViewAllocationOrder.getKeys(mMemoryViewAllocationOrder.lowestValue());
    lassert(keys.size() == 1);

    return null() << *keys.begin();
    }

Nullable<MemoryBlockId> PhysicalAllocations::getOldestBlock()
    {
    if (!mBlockZoneAllocations.size())
        return null();

    const auto& keys = mBlockZoneAllocations.getKeys(mBlockZoneAllocations.lowestValue());
    lassert(keys.size() == 1);

    return null() << *keys.begin();
    }

void PhysicalAllocations::removeBlockFromReplacementQueue(MemoryBlockId block)
    {
    mBlockZoneAllocations.discard(block);
    }

pair<PhysicalMemoryAllocation, int64_t> PhysicalAllocations::allocContaining(uint8_t* addr)
    {
    IntegerRange addressRange = *mPhysicalMemoryAddressesAsRanges.rangeContaining((int64_t)addr);

    PhysicalMemoryAllocation alloc = *mPhysicalMemoryAddresses.getKeys((uint8_t*)addressRange.low()).begin();

    return pair<PhysicalMemoryAllocation, int64_t>(alloc, addr - (uint8_t*)addressRange.low());
    }

void PhysicalAllocations::allocatePhysicalMemory(PhysicalMemoryAllocation allocation)
    {
    if (allocation.zone().isView())
        mMemoryViewAllocationOrder.set(allocation, mIncreasingIndex++);
    else
        mBlockZoneAllocations.set(allocation.zone().getBlock().block(), mIncreasingIndex++);

    mTotalBytesMapped += allocation.byteRange().size();

    uint8_t* actualAddress = mAllocateFunc(allocation);

    lassert(actualAddress);

    mPhysicalMemoryAddresses.set(allocation, actualAddress);

    mPhysicalMemoryAddressesAsRanges.addRange(
        IntegerRange((int64_t)actualAddress, 
                     (int64_t)actualAddress + allocation.byteRange().size())
        );

    mZoneBytecountRangesPhysicallyAllocated[allocation.zone()].addRange(allocation.byteRange());
    }

void PhysicalAllocations::deallocatePhysicalMemory(PhysicalMemoryAllocation allocation)
    {
    lassert(!allocHasCopyTasks(allocation));

    if (allocation.zone().isView())
        mMemoryViewAllocationOrder.discard(allocation);

    mTotalBytesMapped -= allocation.byteRange().size();

    uint8_t* actualAddress = mPhysicalMemoryAddresses.getValue(allocation);

    mDeallocateFunc(allocation, actualAddress);

    mPhysicalMemoryAddresses.discard(allocation);

    mPhysicalMemoryAddressesAsRanges.removeRange(
        IntegerRange((int64_t)actualAddress, (int64_t)actualAddress + allocation.byteRange().size())
        );

    mZoneBytecountRangesPhysicallyAllocated[allocation.zone()].removeRange(allocation.byteRange());
    }

void PhysicalAllocations::setMappableAddress(
            BlockOrViewId target,
            uint8_t* address,
            uint64_t bytecount
            )
    {
    mMappingAddresses.set(target, address);
    }

uint8_t* PhysicalAllocations::getMappableAddress(BlockOrViewId target)
    {
    if (mMappingAddresses.hasKey(target))
        return mMappingAddresses.getValue(target);

    return nullptr;
    }

void PhysicalAllocations::dropMappingTarget(BlockOrViewId target)
    {
    mMappingAddresses.discard(target);
    }

Nullable<pair<BlockOrViewId, int64_t> >
        PhysicalAllocations::translateMappingAddress(uint8_t* mappingBase, uint64_t offsetInMapping)
    {
    if (mMappingAddresses.size() == 0)
        return null();

    if (mMappingAddresses.getKeys(mappingBase).size() == 0)
        return null();

    lassert(mMappingAddresses.getKeys(mappingBase).size() == 1);

    return null() << make_pair(*mMappingAddresses.getKeys(mappingBase).begin(), (int64_t)offsetInMapping);
    }

int64_t PhysicalAllocations::totalBytesMapped() const
    {
    return mTotalBytesMapped;
    }

bool PhysicalAllocations::allocHasCopyTasks(PhysicalMemoryAllocation alloc) const
    {
    return mPhysicalAllocCopyTaskCount.find(alloc) != mPhysicalAllocCopyTaskCount.end();
    }

bool PhysicalAllocations::blockHasCopyTasks(MemoryBlockId block) const
    {
    return mBlockAllocZoneCopyTaskCount.find(block) != mBlockAllocZoneCopyTaskCount.end();
    }

void PhysicalAllocations::copyAddressRefcountChange(uint8_t* addr, Nullable<PhysicalMemoryAllocation> givenAlloc, int64_t direction)
    {
    Nullable<PhysicalMemoryAllocation> alloc = allocForAddress(addr);

    lassert(givenAlloc == alloc);

    if (alloc)
        {
        mPhysicalAllocCopyTaskCount[*alloc] += direction;
        lassert(mPhysicalAllocCopyTaskCount[*alloc] >= 0);

        if (mPhysicalAllocCopyTaskCount[*alloc] == 0)
            mPhysicalAllocCopyTaskCount.erase(*alloc);

        if (alloc->zone().isBlock())
            {
            MemoryBlockId block = alloc->zone().getBlock().block();
            mBlockAllocZoneCopyTaskCount[block] += direction;
            lassert(mBlockAllocZoneCopyTaskCount[block] >= 0);

            if (mBlockAllocZoneCopyTaskCount[block] <= 0)
                mBlockAllocZoneCopyTaskCount.erase(block);
            }
        }
    }
