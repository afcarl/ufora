/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

	   http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include "Axioms.hppml"
#include "Axiom.hppml"
#include "AxiomGroup.hppml"
#include "LibcallAxiomGroup.hppml"
#include <limits>
#include "TypedForaAxiomBuilder.hppml"
#include <boost/math/complex/atan.hpp>
#include <boost/math/special_functions/zeta.hpp>
#include <boost/math/special_functions/digamma.hpp>
#include <boost/math/special_functions/gamma.hpp>
#include <boost/math/special_functions/beta.hpp>
#include <boost/math/distributions/binomial.hpp>
#include <boost/math/distributions/hypergeometric.hpp>
#include <boost/math/distributions/inverse_chi_squared.hpp>
#include <boost/math/distributions/inverse_gamma.hpp>
#include <boost/math/distributions/inverse_gaussian.hpp>
#include <boost/math/distributions/non_central_chi_squared.hpp>
#include <cmath>
#include "../../core/SymbolExport.hpp"
#include "../Core/TupleCategory.hppml"
#include "../Core/ExecutionContext.hppml"
#include "../../../third_party/cephes/bessel/hyp2f1.hpp"
#include "../../../third_party/cephes/beta.hpp"
#include "../../../third_party/cephes/gamma.hpp"

using Fora::Interpreter::ExecutionContext;

#define MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException) \
catch (boost::math::evaluation_error& err) \
	{ \
	new (outException) String( \
		err.what(), \
		ExecutionContext::currentExecutionContext()->getMemoryPool() \
		); \
	return 1; \
	} \
catch (std::domain_error& err) \
	{ \
	new (outException) String( \
		err.what(), \
		ExecutionContext::currentExecutionContext()->getMemoryPool() \
		); \
	return 1; \
	} \
catch (std::overflow_error& err) \
	{ \
	new (outException) String(\
		err.what(), \
		ExecutionContext::currentExecutionContext()->getMemoryPool()   \
		); \
	return 1; \
	} \
catch (std::underflow_error& err) \
	{ \
	new (outException) String(  \
		err.what(),  \
		ExecutionContext::currentExecutionContext()->getMemoryPool() \
		); \
	return 1; \
	}\


extern "C" {

double FORA_clib_cephes_beta(double a, double b)
    {
    return cephes::beta(a, b);
    }

double FORA_clib_cephes_lbeta(double a, double b)
    {
    return cephes::lbeta(a, b);
    }

double FORA_clib_cephes_hyp2f1(double a, double b, double c, double x)
    {
    return cephes::hyp2f1(a, b, c, x);
    }

double FORA_clib_fmod(double x, double y)
	{
	return std::fmod(x, y);
	}

BSA_DLLEXPORT
uword_t FORA_clib_cyl_bessel_i_int64_double(
		double* outNormal, String* outException,
		int64_t v, double x
		)
	{
	try {
		*outNormal = boost::math::cyl_bessel_i<int64_t, double>(v, x);

		return 0;
		}
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException);
	}

BSA_DLLEXPORT
uword_t FORA_clib_cyl_bessel_i_double_double(
		double* outNormal, String* outException,
		double v, double x
		)
	{
	try {
		*outNormal = boost::math::cyl_bessel_i<double, double>(v, x);

		return 0;
		}
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException);
	}

BSA_DLLEXPORT
uword_t FORA_clib_cyl_bessel_k_int64_double(
		double* outNormal, String* outException,
		int64_t v, double x
		)
	{
	try {
		*outNormal = boost::math::cyl_bessel_k<int64_t, double>(v, x);

		return 0;
		}
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException);
	}

BSA_DLLEXPORT
uword_t FORA_clib_cyl_bessel_k_double_double(
		double* outNormal, String* outException,
		double v, double x
		)
	{
	try {
		*outNormal = boost::math::cyl_bessel_k<double, double>(v, x);

		return 0;
		}
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException);
	}


#define def_FORA_clib_inverseGamma_pdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverseGamma_pdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType shape, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::pdf( \
				boost::math::inverse_gamma_distribution<c_floatType>(shape, scale), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverseGamma_pdf_(float, Float32)
def_FORA_clib_inverseGamma_pdf_(double, Float64)

#define def_FORA_clib_inverseGamma_cdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverseGamma_cdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType shape, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::cdf( \
				boost::math::inverse_gamma_distribution<c_floatType>(shape, scale), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverseGamma_cdf_(float, Float32)
def_FORA_clib_inverseGamma_cdf_(double, Float64)

#define def_FORA_clib_inverseGamma_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverseGamma_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType shape, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::quantile( \
				boost::math::inverse_gamma_distribution<c_floatType>(shape, scale), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverseGamma_quantile_(float, Float32)
def_FORA_clib_inverseGamma_quantile_(double, Float64)

#define def_FORA_clib_scaledInverseChiSquared_pdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_scaledInverseChiSquared_pdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::pdf( \
				boost::math::inverse_chi_squared_distribution<c_floatType>(k, scale), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_scaledInverseChiSquared_pdf_(float, Float32)
def_FORA_clib_scaledInverseChiSquared_pdf_(double, Float64)

#define def_FORA_clib_scaledInverseChiSquared_cdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_scaledInverseChiSquared_cdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::cdf( \
				boost::math::inverse_chi_squared_distribution<c_floatType>(k, scale), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_scaledInverseChiSquared_cdf_(float, Float32)
def_FORA_clib_scaledInverseChiSquared_cdf_(double, Float64)

#define def_FORA_clib_scaledInverseChiSquared_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_scaledInverseChiSquared_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::quantile( \
				boost::math::inverse_chi_squared_distribution<c_floatType>(k, scale), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_scaledInverseChiSquared_quantile_(float, Float32)
def_FORA_clib_scaledInverseChiSquared_quantile_(double, Float64)

#define def_FORA_clib_inverseChiSquared_pdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverseChiSquared_pdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::pdf( \
				boost::math::inverse_chi_squared_distribution<c_floatType>(k), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverseChiSquared_pdf_(float, Float32)
def_FORA_clib_inverseChiSquared_pdf_(double, Float64)

#define def_FORA_clib_inverseChiSquared_cdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverseChiSquared_cdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::cdf( \
				boost::math::inverse_chi_squared_distribution<c_floatType>(k), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverseChiSquared_cdf_(float, Float32)
def_FORA_clib_inverseChiSquared_cdf_(double, Float64)

#define def_FORA_clib_inverseChiSquared_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverseChiSquared_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::quantile( \
				boost::math::inverse_chi_squared_distribution<c_floatType>(k), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverseChiSquared_quantile_(float, Float32)
def_FORA_clib_inverseChiSquared_quantile_(double, Float64)

#define def_FORA_clib_noncentralChiSquared_pdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_noncentralChiSquared_pdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType lambda, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::pdf( \
				boost::math::non_central_chi_squared_distribution<c_floatType>(k, lambda), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_noncentralChiSquared_pdf_(float, Float32)
def_FORA_clib_noncentralChiSquared_pdf_(double, Float64)

#define def_FORA_clib_noncentralChiSquared_cdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_noncentralChiSquared_cdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType lambda, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::cdf( \
				boost::math::non_central_chi_squared_distribution<c_floatType>(k, lambda), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_noncentralChiSquared_cdf_(float, Float32)
def_FORA_clib_noncentralChiSquared_cdf_(double, Float64)

#define def_FORA_clib_noncentralChiSquared_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_noncentralChiSquared_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
		c_floatType k, c_floatType lambda, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::quantile( \
				boost::math::non_central_chi_squared_distribution<c_floatType>(k, lambda), \
				x \
				); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_noncentralChiSquared_quantile_(float, Float32)
def_FORA_clib_noncentralChiSquared_quantile_(double, Float64)

#define def_FORA_clib_hypergeometric_pdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_hypergeometric_pdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					uint32_t r, uint32_t n, uint32_t N, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::pdf( \
				boost::math::hypergeometric_distribution<c_floatType>(r, n, N), \
				x \
			); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_hypergeometric_pdf_(float, Float32)
def_FORA_clib_hypergeometric_pdf_(double, Float64)

#define def_FORA_clib_hypergeometric_cdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_hypergeometric_cdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					uint32_t r, uint32_t n, uint32_t N, c_floatType x) \
	{ \
	try { \
		*outNormal = \
			boost::math::cdf( \
				boost::math::hypergeometric_distribution<c_floatType>(r, n, N), \
				x \
			); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_hypergeometric_cdf_(float, Float32)
def_FORA_clib_hypergeometric_cdf_(double, Float64)

#define def_FORA_clib_inverse_gaussian_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverse_gaussian_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
	c_floatType mean, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = boost::math::quantile( \
			boost::math::inverse_gaussian_distribution<c_floatType>(mean, scale), \
			x \
		); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverse_gaussian_quantile_(float, Float32)
def_FORA_clib_inverse_gaussian_quantile_(double, Float64)

#define def_FORA_clib_inverse_gaussian_pdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverse_gaussian_pdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
	c_floatType mean, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = boost::math::pdf( \
			boost::math::inverse_gaussian_distribution<c_floatType>(mean, scale), \
			x \
		); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverse_gaussian_pdf_(float, Float32)
def_FORA_clib_inverse_gaussian_pdf_(double, Float64)

#define def_FORA_clib_inverse_gaussian_cdf_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_inverse_gaussian_cdf_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
	c_floatType mean, c_floatType scale, c_floatType x) \
	{ \
	try { \
		*outNormal = boost::math::cdf( \
			boost::math::inverse_gaussian_distribution<c_floatType>(mean, scale), \
			x \
		); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_inverse_gaussian_cdf_(float, Float32)
def_FORA_clib_inverse_gaussian_cdf_(double, Float64)

#define def_FORA_clib_hypergeometric_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_hypergeometric_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
						uint32_t r, uint32_t n, uint32_t N, c_floatType x, Symbol_raw(inPolicySymbol)) \
	{ \
	Symbol_assemble(inPolicySymbol); \
	using namespace boost::math::policies; \
	using namespace boost::math; \
	\
	try { \
		if (inPolicySymbol == Symbol::Nothing()) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::hypergeometric_distribution<c_floatType>(r, n, N), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundOutwards")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::hypergeometric_distribution<c_floatType>(r, n, N), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundInwards")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::hypergeometric_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_inwards> > >(r, n, N), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundDown")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::hypergeometric_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_down> > >(r, n, N), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundUp")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::hypergeometric_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_up> > >(r, n, N), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundNearest")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::hypergeometric_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_nearest> > >(r, n, N), \
					x \
				); \
			return 0; \
			} \
		else { \
			new (outException) String( \
				"bad policy symbol passed in",\
				ExecutionContext::currentExecutionContext()->getMemoryPool() \
				); \
			return 1; \
			} \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_hypergeometric_quantile_(float, Float32)
def_FORA_clib_hypergeometric_quantile_(double, Float64)

#define def_FORA_clib_binomial_distribution_quantile_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_binomial_distribution_quantile_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType n, c_floatType p, c_floatType x, Symbol_raw(inPolicySymbol)) \
	{ \
	Symbol_assemble(inPolicySymbol); \
	using namespace boost::math::policies; \
	using namespace boost::math; \
	\
	try { \
		if (inPolicySymbol == Symbol::Nothing()) \
			{ \
			*outNormal = \
			   boost::math::quantile( \
					boost::math::binomial_distribution<c_floatType>(n, p), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundOutwards")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::binomial_distribution<c_floatType>(n, p), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundInwards")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::binomial_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_inwards> > >(n, p), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundDown")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::binomial_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_down> > >(n, p), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundUp")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::binomial_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_up> > >(n, p), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("integerRoundNearest")) \
			{ \
			*outNormal = \
				boost::math::quantile( \
					boost::math::binomial_distribution<c_floatType, \
						policy<discrete_quantile<integer_round_nearest> > >(n, p), \
					x \
				); \
			return 0; \
			} \
		else if (inPolicySymbol == Symbol("real")) \
			{ \
			boost::math::binomial_distribution< \
				double, \
				boost::math::policies::policy< \
					boost::math::policies::discrete_quantile< \
						boost::math::policies::real \
						> \
					> \
				> binom(n, p); \
			\
			*outNormal = \
				boost::math::quantile( \
					binom, \
					x \
				); \
			return 0; \
			} \
		else { \
			new (outException) String(\
				"bad policy symbol passed in",  \
				ExecutionContext::currentExecutionContext()->getMemoryPool() \
				); \
			return 1; \
			} \
		}\
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_binomial_distribution_quantile_(float, Float32)
def_FORA_clib_binomial_distribution_quantile_(double, Float64)

#define def_FORA_clib_beta_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_beta_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::beta<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_beta_(float, Float32)
def_FORA_clib_beta_(double, Float64)

#define def_FORA_clib_ibeta_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibeta_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = boost::math::ibeta<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibeta_(float, Float32)
def_FORA_clib_ibeta_(double, Float64)


#define def_FORA_clib_ibetac_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibetac_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = boost::math::ibetac<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibetac_(float, Float32)
def_FORA_clib_ibetac_(double, Float64)


#define def_FORA_clib_beta_incomplete_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_beta_incomplete_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = boost::math::beta<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_beta_incomplete_(float, Float32)
def_FORA_clib_beta_incomplete_(double, Float64)


#define def_FORA_clib_betac_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_betac_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = boost::math::betac<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_betac_(float, Float32)
def_FORA_clib_betac_(double, Float64)


#define def_FORA_clib_ibeta_inv_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibeta_inv_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibeta_inv<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibeta_inv_(float, Float32)
def_FORA_clib_ibeta_inv_(double, Float64)


#define def_FORA_clib_ibetac_inv_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibetac_inv_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibetac_inv<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibetac_inv_(float, Float32)
def_FORA_clib_ibetac_inv_(double, Float64)


#define def_FORA_clib_ibeta_inva_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibeta_inva_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibeta_inva<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibeta_inva_(float, Float32)
def_FORA_clib_ibeta_inva_(double, Float64)


#define def_FORA_clib_ibetac_inva_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibetac_inva_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibetac_inva<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibetac_inva_(float, Float32)
def_FORA_clib_ibetac_inva_(double, Float64)


#define def_FORA_clib_ibeta_invb_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibeta_invb_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibeta_invb<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibeta_invb_(float, Float32)
def_FORA_clib_ibeta_invb_(double, Float64)


#define def_FORA_clib_ibetac_invb_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibetac_invb_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibetac_invb<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibetac_invb_(float, Float32)
def_FORA_clib_ibetac_invb_(double, Float64)


#define def_FORA_clib_ibeta_derivative_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_ibeta_derivative_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2, c_floatType arg3) \
	{ \
	try { \
		*outNormal = \
			boost::math::ibeta_derivative<c_floatType, c_floatType, c_floatType>(arg1, arg2, arg3); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_ibeta_derivative_(float, Float32)
def_FORA_clib_ibeta_derivative_(double, Float64)


#define def_FORA_clib_arctan_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_arctan_ ## \
fora_floatTypename(pair<c_floatType, c_floatType>* outNormal, String* outException, \
					c_floatType realPart, c_floatType imaginaryPart) \
	{ \
	try { \
		auto boost_ret = boost::math::atan(std::complex<c_floatType>(realPart, imaginaryPart)); \
		*outNormal = make_pair(boost_ret.real(), boost_ret.imag()); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

//std::complex is only valid on float types -- all other behavior is undefined
def_FORA_clib_arctan_(float, Float32)
def_FORA_clib_arctan_(double, Float64)

#define def_FORA_clib_tgamma_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
c_floatType FORA_clib_tgamma_ ## \
fora_floatTypename(c_floatType arg) \
	{ \
	return cephes::Gamma(arg);\
	} \

def_FORA_clib_tgamma_(float, Float32)
def_FORA_clib_tgamma_(double, Float64)


#define def_FORA_clib_lgamma_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
c_floatType FORA_clib_lgamma_ ## \
fora_floatTypename(c_floatType arg) \
	{ \
	return cephes::lgam(arg); \
	} \

def_FORA_clib_lgamma_(float, Float32)
def_FORA_clib_lgamma_(double, Float64)

#define def_FORA_clib_digamma_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_digamma_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, c_floatType arg) \
	{ \
	try { \
		*outNormal = boost::math::digamma<c_floatType>(arg); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_digamma_(float, Float32)
def_FORA_clib_digamma_(double, Float64)

#define def_FORA_clib_tgamma_ratio_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_tgamma_ratio_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::tgamma_ratio<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_tgamma_ratio_(float, Float32)
def_FORA_clib_tgamma_ratio_(double, Float64)


#define def_FORA_clib_gamma_p_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_p_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_p<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_p_(float, Float32)
def_FORA_clib_gamma_p_(double, Float64)


#define def_FORA_clib_gamma_p_inv_(c_floatType, fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_p_inv_ ## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_p_inv<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_p_inv_(float, Float32)
def_FORA_clib_gamma_p_inv_(double, Float64)


#define def_FORA_clib_gamma_p_inva_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_p_inva_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_p_inva<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_p_inva_(float, Float32)
def_FORA_clib_gamma_p_inva_(double, Float64)


#define def_FORA_clib_gamma_p_derivative_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_p_derivative_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_p_derivative<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_p_derivative_(float, Float32)
def_FORA_clib_gamma_p_derivative_(double, Float64)


#define def_FORA_clib_gamma_q_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_q_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_q<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_q_(float, Float32)
def_FORA_clib_gamma_q_(double, Float64)


#define def_FORA_clib_gamma_q_inv_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_q_inv_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_q_inv<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_q_inv_(float, Float32)
def_FORA_clib_gamma_q_inv_(double, Float64)


#define def_FORA_clib_gamma_q_inva_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_gamma_q_inva_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::gamma_q_inva<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_gamma_q_inva_(float, Float32)
def_FORA_clib_gamma_q_inva_(double, Float64)


#define def_FORA_clib_tgamma_lower_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_tgamma_lower_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::tgamma_lower<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_tgamma_lower_(float, Float32)
def_FORA_clib_tgamma_lower_(double, Float64)


#define def_FORA_clib_tgamma_incomplete_(c_floatType,fora_floatTypename) \
BSA_DLLEXPORT \
uword_t FORA_clib_tgamma_incomplete_## \
fora_floatTypename(c_floatType* outNormal, String* outException, \
					c_floatType arg1, c_floatType arg2) \
	{ \
	try { \
		*outNormal = boost::math::tgamma<c_floatType, c_floatType>(arg1, arg2); \
		return 0; \
		} \
	MACRO_HANDLE_BOOST_MATH_EXCEPTION(outException); \
	} \

def_FORA_clib_tgamma_incomplete_(float, Float32)
def_FORA_clib_tgamma_incomplete_(double, Float64)

}

class MathSpecialFunctionsAxioms {
public:

	ImmutableTreeVector<Type> mFloatTypes;

	MathSpecialFunctionsAxioms()
		{
		setupTypes();
		dumpAxioms();
		dumpCylBesselFunctionAxioms();
		dumpCephesMathLibrarySpecialFunctions();
		}

	void setupTypes()
		{
		mFloatTypes = mFloatTypes + Type::Float(32) + Type::Float(64);
		}

	void dumpCephesMathLibrarySpecialFunctions()
		{
		AxiomGroups("MathSpecialFunction") +=
			Fora::LibcallAxiomGroup::create(
				JOVT() +
					"hyp2f1" +
					"Call" +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)),
				Fora::ReturnSlots() + JOV::OfType(Type::Float(64)),
				&FORA_clib_cephes_hyp2f1,
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4 + 5
				);

		AxiomGroups("MathSpecialFunction") +=
			Fora::LibcallAxiomGroup::create(
				JOVT() +
					"cephes_beta" +
					"Call" +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)),
				Fora::ReturnSlots() + JOV::OfType(Type::Float(64)),
				&FORA_clib_cephes_beta,
				ImmutableTreeVector<uword_t>() + 2 + 3
				);

		AxiomGroups("MathSpecialFunction") +=
			Fora::LibcallAxiomGroup::create(
				JOVT() +
					"cephes_lbeta" +
					"Call" +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)),
				Fora::ReturnSlots() + JOV::OfType(Type::Float(64)),
				&FORA_clib_cephes_lbeta,
				ImmutableTreeVector<uword_t>() + 2 + 3
				);
		}

	void dumpCylBesselFunctionAxioms()
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"cyl_bessel_i" +
					"Call" +
					JOV::OfType(Type::Integer(64, true)) +
					JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::String()),
				"FORA_clib_cyl_bessel_i_int64_double",
				ImmutableTreeVector<uword_t>() + 2 + 3
				);
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"cyl_bessel_i" +
					"Call" +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::String()),
				"FORA_clib_cyl_bessel_i_double_double",
				ImmutableTreeVector<uword_t>() + 2 + 3
				);
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"cyl_bessel_k" +
					"Call" +
					JOV::OfType(Type::Integer(64, true)) +
					JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::String()),
				"FORA_clib_cyl_bessel_k_int64_double",
				ImmutableTreeVector<uword_t>() + 2 + 3
				);
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"cyl_bessel_k" +
					"Call" +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::Float(64)),
				JOV::OfType(Type::String()),
				"FORA_clib_cyl_bessel_k_double_double",
				ImmutableTreeVector<uword_t>() + 2 + 3
				);
			}

	void dumpAxioms()
		{
		AxiomGroups("MathSpecialFunction") +=
			Fora::LibcallAxiomGroup::create(
				JOVT() +
					"fmod" +
					"Call" +
					JOV::OfType(Type::Float(64)) +
					JOV::OfType(Type::Float(64)),
				Fora::ReturnSlots() + JOV::OfType(Type::Float(64)),
				&FORA_clib_fmod,
				ImmutableTreeVector<uword_t>() + 2 + 3
				);

		for (uword_t s = 0; s < mFloatTypes.size(); s++)
			{
			dumpAtanAxiomForFloatType(mFloatTypes[s]);
			dumpGammaFunctionAxiomsForFloatType(mFloatTypes[s]);
			dumpBetaFunctionAxiomsForFloatType(mFloatTypes[s]);
			dumpBinomialDistributionAxiomsForFloatType(mFloatTypes[s]);
			dumpHypergeometricDistributionAxiomsForFloatType(mFloatTypes[s]);
			dumpInverseGaussianDistributionAxiomsForFloatType(mFloatTypes[s]);
			dumpNoncentralChiSquaredDistributionAxiomsForFloatType(mFloatTypes[s]);
			dumpInverseChiSquaredDistributionAxiomsForFloatType(mFloatTypes[s]);
			dumpInverseGammaDistributionAxiomsForFloatType(mFloatTypes[s]);
			dumpScaledInverseChiSquaredDistributionAxiomsForFloatType(mFloatTypes[s]);
			}
		}

	void dumpInverseGaussianDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
				"inverseGaussianQuantile" +
				"Call" +
				JOV::OfType(floatType) +
				JOV::OfType(floatType) +
				JOV::OfType(floatType) +
				JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverse_gaussian_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
				"inverseGaussianPdf" +
				"Call" +
				JOV::OfType(floatType) +
				JOV::OfType(floatType) +
				JOV::OfType(floatType) +
				JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverse_gaussian_pdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
				"inverseGaussianCdf" +
				"Call" +
				JOV::OfType(floatType) +
				JOV::OfType(floatType) +
				JOV::OfType(floatType) +
				JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverse_gaussian_cdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);
		}

	void dumpHypergeometricDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"hypergeometricPdf" +
					"Call" +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_hypergeometric_pdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4 + 5
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"hypergeometricCdf" +
					"Call" +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_hypergeometric_cdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4 + 5
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"hypergeometricQuantile" +
					"Call" +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(Type::Integer(32, false)) +
					JOV::OfType(floatType) +
					JOV::OfType(Type::Symbol()) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_hypergeometric_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4 + 5 + 6
			);
		}

	void dumpNoncentralChiSquaredDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"noncentralChiSquaredPdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_noncentralChiSquared_pdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"noncentralChiSquaredCdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_noncentralChiSquared_cdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"noncentralChiSquaredQuantile" +
					"Call" +
 					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_noncentralChiSquared_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);
		}

	void dumpInverseChiSquaredDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"inverseChiSquaredPdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverseChiSquared_pdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"inverseChiSquaredCdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverseChiSquared_cdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"inverseChiSquaredQuantile" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverseChiSquared_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);
		}

	void dumpInverseGammaDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"inverseGammaPdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverseGamma_pdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"inverseGammaCdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverseGamma_cdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"inverseGammaQuantile" +
					"Call" +
 					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_inverseGamma_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);
		}

	void dumpScaledInverseChiSquaredDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"scaledInverseChiSquaredPdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_scaledInverseChiSquared_pdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"scaledInverseChiSquaredCdf" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_scaledInverseChiSquared_cdf_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"scaledInverseChiSquaredQuantile" +
					"Call" +
 					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_scaledInverseChiSquared_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);
		}

	void dumpBinomialDistributionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"binomQuantile" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(Type::Symbol()) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_binomial_distribution_quantile_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4 + 5
			);
		}

	void dumpBetaFunctionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"beta" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_beta_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibeta" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibeta_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 +4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetac" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibetac_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"beta" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_beta_incomplete_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"betac" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_betac_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetaInv" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibeta_inv_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetacInv" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibetac_inv_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetaInva" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibeta_inva_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetacInva" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibetac_inva_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetaInvb" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibeta_invb_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetacInvb" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibetac_invb_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"ibetaDerivative" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_ibeta_derivative_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3 + 4
			);
		}

	void dumpAtanAxiomForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"atan" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::Tuple(
					JudgmentOnValueTuple(
						emptyTreeVec()
							+ JOV::OfType(floatType)
							+ JOV::OfType(floatType),
						emptyTreeVec()
							+ Nullable<Symbol>()
							+ Nullable<Symbol>(),
						JOVTE::NoExtras()
						)
					),
				JOV::OfType(Type::String()),
				"FORA_clib_arctan_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
				);
		}

	void dumpGammaFunctionAxiomsForFloatType(const Type& floatType)
		{
		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"tgamma" +
					"Call" +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				"FORA_clib_tgamma_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"lgamma" +
					"Call" +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				"FORA_clib_lgamma_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"digamma" +
					"Call" +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(floatType),
				"FORA_clib_digamma_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"tgammaRatio" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_tgamma_ratio_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaP" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_p_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaPInv" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_p_inv_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaPDerivative" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_p_derivative_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaPInva" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_p_inva_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaQ" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_q_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaQInv" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_q_inv_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"gammaQInva" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_gamma_q_inva_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"tgammaLower" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_tgamma_lower_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);

		AxiomGroups("MathSpecialFunction") +=
			AxiomGroup::libcallAxiomGroup(
				JOVT() +
					"tgamma" +
					"Call" +
					JOV::OfType(floatType) +
					JOV::OfType(floatType) +
					JOVTE::NoExtras(),
				JOV::OfType(floatType),
				JOV::OfType(Type::String()),
				"FORA_clib_tgamma_incomplete_" + floatType.toString(),
				ImmutableTreeVector<uword_t>() + 2 + 3
			);
		}
};

MathSpecialFunctionsAxioms mathSpecialFunctionsAxioms;

