/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "VectorDataManager.hppml"
#include "VectorDataMappedMemory.hppml"
#include "VectorDataMemoryManager.hppml"
#include "../Core/ExecutionContext.hppml"
#include "../Core/ExecutionContextImpl.hppml"
#include "../TypedFora/ABI/BigVectorLayouts.hppml"
#include "../../core/Clock.hpp"
#include "../../core/Logging.hpp"
#include "../../core/MemoryViews/BlockDataPlacements.hppml"
#include "../../core/MemoryViews/MemoryViewDefinition.hppml"
#include "../../core/MemoryViews/OnDemandMemoryRegions.hppml"


class VectorDataMappedMemoryImpl : public PolymorphicSharedPtrBase<VectorDataMappedMemoryImpl> {
public:
    VectorDataMappedMemoryImpl(
                PolymorphicSharedPtr<CallbackScheduler> inCallbackScheduler,
                PolymorphicSharedPtr<VectorDataMemoryManager> inVDMM,
                PolymorphicSharedPtr<TypedFora::Abi::BigVectorLayouts> inBigVectorLayouts,
                int64_t maxBytesOfScratchMemory
                ) :
            mDataLoadRequiredEvent(inCallbackScheduler),
            mVDMM(inVDMM),
            mPageLayouts(inBigVectorLayouts),
            mMemoryRegions(
                boost::bind(&VectorDataMappedMemoryImpl::onThreadBlocked, this, boost::arg<1>()),
                boost::bind(&VectorDataMappedMemoryImpl::extractCurrentBlockedThreadInfo, this),
                "/ufora"
                ),
            mTotalTasks(0),
            mTotalTaskBytes(0),
            mLastLogMessage(0)
        {
        mBlockDataPlacement.reset(
            new BlockDataPlacements(
                mMemoryRegions.pageSize(),
                [&](PhysicalMemoryAllocation alloc) {
                    return mMemoryRegions.allocateSharedRegion(
                        mMemoryRegions.roundUpToPageSize(alloc.byteRange().size())
                        );
                    },
                [&](PhysicalMemoryAllocation dealloc, uint8_t* ptr) {
                    mMemoryRegions.freeSharedRegion(ptr);
                    },
                [&](uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount) {
                    return mMemoryRegions.mapShareableRegion(sharedBase, sharedOffset, mapBase, mapOffset, bytecount);
                    },
                [&](uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount) {
                    return mMemoryRegions.unmap(mapBase, mapOffset, bytecount);
                    },
                [&](MemoryBlockId block, IntegerRange range) {
                    mDataLoadRequiredEvent.broadcast(
                        VectorDataMappedMemory::DataLoadRequiredEvent(
                            getPageId(block),
                            range
                            )
                        );
                    },
                maxBytesOfScratchMemory,
                512
                )
            );
        }

    void setSignalMaskOnCurrentThread()
        {
        mMemoryRegions.setSignalMaskOnCurrentThread();
        }

    void onThreadBlocked(OnDemandMemoryRegions::BlockingThread thread)
        {
        boost::mutex::scoped_lock lock(mMutex);

        Nullable<pair<BlockOrViewId, int64_t> > addr =
            mBlockDataPlacement->translateMappingAddress(
                thread.mappableRegion(),
                thread.offsetInRegion()
                );

        lassert_dump(addr, "ExecutionContext accessed a mappable region for which we have no definition.");

        Fora::PageId pageTouched;
        @match BlockOrViewId(addr->first)
            -| Block(id) ->> {
                pageTouched = getPageId(id);
                }
            -| View(id) ->> { pageTouched = mPageLayouts->getLayoutForId(id.guid()).pageAtIndex(addr->second); }

        auto context = ((Fora::Interpreter::ExecutionContext*)thread.blockingThreadPtr());

        context->getImpl()->touchedBigvecMemory(pageTouched);

        mBlockDataPlacement->markThreadBlockedOn(addr->first, addr->second);

        performBackgroundCopyTasks_(lock);

        if (!mBlockDataPlacement->byteIsMapped(addr->first, addr->second))
            context->interrupt();
        }

    void* extractCurrentBlockedThreadInfo()
        {
        Fora::Interpreter::ExecutionContext* context =
            Fora::Interpreter::ExecutionContext::currentExecutionContext();

        if (!context)
            return nullptr;

        if (context->getVDM().getMemoryManager() == mVDMM)
            return context;

        return nullptr;
        }

    uint8_t* allocateAddressForPage(const Fora::PageId& inPage, int64_t valueCount, int64_t valueStride)
        {
        boost::mutex::scoped_lock lock(mMutex);

        auto blockId = makeBlockOrViewId(inPage);

        mPageAddressRefcounts[inPage]++;

        if (mPageAddressRefcounts[inPage] > 1)
            return mBlockDataPlacement->getMappableAddress(blockId);

        uint64_t bytecount = mMemoryRegions.roundUpToPageSize(valueCount * valueStride);

        auto ptr = mMemoryRegions.allocateMappableRegion(bytecount);

        lassert(ptr);

        mBlockDataPlacement->setMappableAddress(blockId, ptr, bytecount);

        return ptr;
        }

    void deallocateAddressForPage(const Fora::PageId& inPage)
        {
        boost::mutex::scoped_lock lock(mMutex);

        auto blockId = makeBlockOrViewId(inPage);

        mPageAddressRefcounts[inPage]--;

        if (mPageAddressRefcounts[inPage] == 0)
            {
            uint8_t* addr = mBlockDataPlacement->getMappableAddress(blockId);

            mMemoryRegions.releaseMappableRegion(addr);

            mBlockDataPlacement->dropMappingTarget(blockId);
            }
        }

    uint8_t* addressForBigvec(const Fora::BigVectorId& inBigVec)
        {
        boost::mutex::scoped_lock lock(mMutex);

        if (inBigVec.jor().size() != 1 || !inBigVec.jor()[0].type() || !inBigVec.jor()[0].type()->isPOD())
            return nullptr;

        auto viewId = makeBlockOrViewId(inBigVec);
        uint8_t* ptr = mBlockDataPlacement->getMappableAddress(viewId);

        if (ptr)
            return ptr;

        auto layout = mPageLayouts->getLayoutForId(inBigVec);
        auto viewDefinition = makeMemoryViewDefinition(layout);
        mBlockDataPlacement->addMemoryViewDefinition(viewDefinition);

        uint64_t bytecount = mMemoryRegions.roundUpToPageSize(inBigVec.size() * inBigVec.jor()[0].type()->size());

        ptr = mMemoryRegions.allocateMappableRegion(bytecount);
        if (!ptr)
            return nullptr;

        mBlockDataPlacement->setMappableAddress(viewId, ptr, bytecount);

        return ptr;
        }

    void bigvecDroppedAcrossEntireSystem(const Fora::BigVectorId& inBigVec)
        {
        boost::mutex::scoped_lock lock(mMutex);

        auto viewId = makeBlockOrViewId(inBigVec);
        uint8_t* ptr = mBlockDataPlacement->getMappableAddress(viewId);
        if (!ptr)
            return;

        mMemoryRegions.releaseMappableRegion(ptr);

        mBlockDataPlacement->dropMappingTarget(viewId);
        }

    bool allocatePageData(
                    const Fora::PageId& inPage,
                    IntegerRange byteRange,
                    uint8_t* addr
                    )
        {
        boost::mutex::scoped_lock lock(mMutex);

        mBlockDataPlacement->allocateBlockData(makeMemoryBlockId(inPage), byteRange, addr);

        performBackgroundCopyTasks_(lock);

        return true;
        }

    void deallocatePageData(const Fora::PageId& inPage)
        {
        boost::mutex::scoped_lock lock(mMutex);

        //invalidate all references to 'inPage'
        mBlockDataPlacement->dropAllDataForBlock(makeMemoryBlockId(inPage));

        //free any memory we happen to need in the background
        performBackgroundCopyTasks_(lock);
        }

    EventBroadcaster<VectorDataMappedMemory::DataLoadRequiredEvent>& getOnDataLoadRequiredEvent()
        {
        return mDataLoadRequiredEvent;
        }

private:
    void performBackgroundCopyTasks_(boost::mutex::scoped_lock& ioLock)
        {
        while (Nullable<DataCopyTask> p = mBlockDataPlacement->extractTask())
            {
            mTotalTasks++;
            mTotalTaskBytes += p->bytecount();

            ioLock.unlock();

            p->copy();

            ioLock.lock();

            mBlockDataPlacement->taskComplete(*p);
            }

        if (curClock() - mLastLogMessage > 1.0)
            {
            LOG_DEBUG << "VectorDataMappedMemory did " << mTotalTaskBytes / 1024 / 1024.0 << " MB over "
                << mTotalTasks << " tasks.";
            mLastLogMessage = curClock();
            }
        }

    Fora::PageId getPageId(const MemoryBlockId& inBlock)
        {
        auto it = mPageForBlock.find(inBlock);
        lassert_dump(it != mPageForBlock.end(), "cannot find page for block with id:" << prettyPrintString(inBlock));
        return it->second;
        }
    MemoryBlockId makeMemoryBlockId(const Fora::PageId& inPage)
        {
        auto block = MemoryBlockId(inPage.guid());

        auto it = mPageForBlock.find(block);
        if (it != mPageForBlock.end())
            {
            lassert(it->second == inPage)
            }
        mPageForBlock[block] = inPage;
        return block;
        }

    MemoryViewId makeMemoryViewId(const Fora::BigVectorId& inBigVec)
        {
        return MemoryViewId(inBigVec.guid());
        }
    BlockOrViewId makeBlockOrViewId(const Fora::PageId& inPage)
        {
        return BlockOrViewId::Block(makeMemoryBlockId(inPage));
        }
    BlockOrViewId makeBlockOrViewId(const Fora::BigVectorId& inBigVec)
        {
        return BlockOrViewId::View(makeMemoryViewId(inBigVec));
        }
    MemoryViewDefinition makeMemoryViewDefinition(const TypedFora::Abi::BigVectorPageLayout& inLayout)
        {
        ImmutableTreeVector<MemoryViewDefinitionTerm> terms = emptyTreeVec();
        for (auto slice : inLayout.vectorIdentities())
            {
            lassert_dump(slice.vector().isInternal(),
                "don't know yet how to translate an external VectorDataID to a memory block");
            terms = terms +
                MemoryViewDefinitionTerm::ViewOfBlock(
                    makeMemoryBlockId(slice.vector().getInternal().page()),
                    slice.slice()
                    );
            }
        return MemoryViewDefinition(makeMemoryViewId(inLayout.identity()), terms);
        }

    boost::mutex mMutex;

    int64_t mTotalTasks;

    int64_t mTotalTaskBytes;

    double mLastLogMessage;

    boost::shared_ptr<BlockDataPlacements> mBlockDataPlacement;

    map<Fora::PageId, int64_t> mPageAddressRefcounts;

    map<MemoryBlockId, Fora::PageId> mPageForBlock;

    EventBroadcaster<VectorDataMappedMemory::DataLoadRequiredEvent> mDataLoadRequiredEvent;

    PolymorphicSharedPtr<VectorDataMemoryManager> mVDMM;

    PolymorphicSharedPtr<TypedFora::Abi::BigVectorLayouts> mPageLayouts;

    OnDemandMemoryRegions mMemoryRegions;
};


VectorDataMappedMemory::VectorDataMappedMemory(
            PolymorphicSharedPtr<CallbackScheduler> inCallbackScheduler,
            PolymorphicSharedPtr<VectorDataMemoryManager> inVDMM,
            PolymorphicSharedPtr<TypedFora::Abi::BigVectorLayouts> inBigVectorLayouts,
            int64_t maxBytesOfScratchMemory
            ) :
        mImpl(
            new VectorDataMappedMemoryImpl(
                inCallbackScheduler,
                inVDMM,
                inBigVectorLayouts,
                maxBytesOfScratchMemory
                )
            )
    {
    }

uint8_t* VectorDataMappedMemory::addressForBigvec(const Fora::BigVectorId& id)
    {
    return mImpl->addressForBigvec(id);
    }

uint8_t* VectorDataMappedMemory::allocateAddressForPage(const Fora::PageId& inPage, int64_t valueCount, int64_t valueStride)
    {
    return mImpl->allocateAddressForPage(inPage, valueCount, valueStride);
    }

void VectorDataMappedMemory::deallocateAddressForPage(const Fora::PageId& inPage)
    {
    mImpl->deallocateAddressForPage(inPage);
    }

void VectorDataMappedMemory::bigvecDroppedAcrossEntireSystem(const Fora::BigVectorId& id)
    {
    mImpl->addressForBigvec(id);
    }

bool VectorDataMappedMemory::allocatePageData(
                const Fora::PageId& inPage,
                IntegerRange byteRange,
                uint8_t* addr
                )
    {
    return mImpl->allocatePageData(inPage, byteRange, addr);
    }

void VectorDataMappedMemory::visitPageData(
                const Fora::PageId& inPage,
                boost::function<void (uint8_t*, IntegerRange)> inVisitFunc
                )
    {
    lassert_dump(false, "not implemented");
    }


void VectorDataMappedMemory::deallocatePageData(const Fora::PageId& inPage)
    {
    mImpl->deallocatePageData(inPage);
    }

EventBroadcaster<VectorDataMappedMemory::DataLoadRequiredEvent>& VectorDataMappedMemory::getOnDataLoadRequiredEvent()
    {
    return mImpl->getOnDataLoadRequiredEvent();
    }

void VectorDataMappedMemory::setSignalMaskOnCurrentThread()
    {
    mImpl->setSignalMaskOnCurrentThread();
    }
