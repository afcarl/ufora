/***************************************************************************
    Copyright 2016 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "PageDataPlacements.hppml"
#include "OnDemandMemoryRegions.hppml"

#include "../../core/UnitTest.hpp"
#include "../../core/UnitTestCppml.hpp"
#include "../../core/Logging.hpp"
#include "../../core/threading/Queue.hpp"
#include "../../core/math/Random.hpp"

using namespace TypedFora::Abi;

class PageDataPlacementsTest {
public:
    PageDataPlacementsTest() :
            mMemoryRegions(
                [&](OnDemandMemoryRegions::BlockingThread t) { 
                    LOG_CRITICAL << "this should never happen.";
                    fflush(stdout);
                    fflush(stderr);
                    _exit(1);
                    },
                []() -> void* { return (void*)1; },
                "/ufora"
                ),
            mPageSize(mMemoryRegions.pageSize()),
            mPlacements(
                mPageSize,
                [&](PhysicalMemoryAllocation alloc) {
                    mAllocOps++;
                    return mMemoryRegions.allocateSharedRegion(alloc.byteRange().size());
                    },
                [&](PhysicalMemoryAllocation dealloc, uint8_t* ptr) {
                    mMemoryRegions.freeSharedRegion(ptr);
                    },
                [&](uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount) {
                    mMapOps++;
                    return mMemoryRegions.mapShareableRegion(sharedBase, sharedOffset, mapBase, mapOffset, bytecount);
                    },
                [&](uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount) {
                    mMapOps++;
                    return mMemoryRegions.unmap(mapBase, mapOffset, bytecount);
                    },
                [&](Fora::PageId page, IntegerRange range) {
                    mNeededPageRegions.write(make_pair(page, range));
                    mPageUploadOps++;
                    },
                1024 * 1024,
                32
                ),
            mBytesPerPage(1024 * 128),
            mRandom(1),
            mCopyBytes(0),
            mCopyOps(0),
            mMapOps(0),
            mAllocOps(0),
            mPageUploadOps(0)
        {
        allocatePages(10);
        allocateBigvecs(20);
        }

    Fora::PageId testPage(int i)
        {
        return Fora::PageId(hash_type(i), mBytesPerPage, mBytesPerPage);
        }

    void allocatePages(int64_t count)
        {
        int64_t value = 0;

        for (int64_t k = 0; k < count;k++)
            {
            mPages.push_back(testPage(k));
            for (int64_t k = 0; k < mBytesPerPage / sizeof(int64_t)+1;k++)
                mPageDatas[mPages.back()].push_back(value++);
            }
        }

    void allocateBigvecs(int64_t bigvecs)
        {
        for (long k = 0; k < bigvecs; k++)
            {
            ImmutableTreeVector<VectorDataIDSlice> slices;

            long pages = 2 + mRandom() * 10;

            ImmutableTreeVector<pair<int64_t, IntegerRange> > counts;

            for (long p = 0; p < pages; p++)
                {
                int64_t width = mPageSize * (1 + int(mRandom() * 14));
                int64_t offset = mPageSize * int(mRandom() * 14);

                if (mRandom() < .25)
                    {
                    //let's make the page width weird
                    if (mRandom() < .1)
                        //really weird
                        width -= mRandom() * 125;
                    else
                        //just a little weird
                        width -= mPageSize / 2;
                    }

                if (mRandom() < .5)
                    offset += mRandom() * 512;

                lassert(offset+width < mBytesPerPage);

                slices = slices + VectorDataIDSlice(
                    VectorDataID::Internal(mPages[mRandom() * mPages.size()], 0), 
                    IntegerRange(offset, offset+width)
                    );
                }

            BigVectorPageLayout layout(
                slices, 
                JudgmentOnResult(JOV::OfType(Type::Integer(8, false))), 
                hashValue(slices)
                );
                
            mBigVectorLayouts[layout.identity()] = layout;
            mBigVectorIds.push_back(layout.identity());
            }
        }

    void touchRandomly(long count)
        {
        for (long k = 0; k < count; k++)
            touchARandomPage();

        int64_t totalBytes = 0;
        for (auto& pageAndData: mPageDatas)
            totalBytes += pageAndData.second.size() * sizeof(int64_t);

        LOG_INFO << "after " << count << " value touches:\n"
            << "MB copied: " << mCopyBytes / 1024 / 1024.0 << "\n"
            << "Copy operations: " << mCopyOps << "\n"
            << "Bytes/copy operation: " << mCopyBytes / mCopyOps << "\n"
            << "Map ops: " << mMapOps << "\n"
            << "Alloc ops: " << mAllocOps << "\n"
            << "page upload ops: " << mPageUploadOps << "\n"
            << "Total mb of page data: " << totalBytes / 1024 / 1024.0
            ;
        }

    void touchARandomPage()
        {
        BigvecOrPageId ent = pickRandomEntity();
        int64_t bytecount;

        if (ent.isPage())
            bytecount = mBytesPerPage;
        else
            bytecount = ent.getBigvec().bigvec().size();

        int64_t aRandomByte = mRandom() * bytecount;

        lassert(aRandomByte < bytecount);

        LOG_DEBUG << "Checking byte " << aRandomByte << " in " << bytecount << " of " << ent;

        if (!mPlacements.getMappableAddress(ent))
            {
            if (ent.isBigvec())
                mPlacements.addBigVecPageLayout(mBigVectorLayouts[ent.getBigvec().bigvec()]);

            mPlacements.setMappableAddress(ent, mMemoryRegions.allocateMappableRegion(bytecount), bytecount);
            }

        if (!mPlacements.byteIsMapped(ent, aRandomByte))
            {
            mPlacements.markThreadBlockedOn(ent, aRandomByte);

            updateAll();

            lassert_dump(
                mPlacements.byteIsMapped(ent, aRandomByte),
                "Were not able to map byte " << aRandomByte << " of " << prettyPrintString(ent)
                );
            }

        uint8_t byte = mPlacements.getMappableAddress(ent)[aRandomByte];

        lassert_dump(byte == computeByteForEntity(ent, aRandomByte), 
            "expected " << prettyPrintString(ent) << " byte " << aRandomByte 
                << " to be " << (long)computeByteForEntity(ent, aRandomByte) << " but got " << (long)byte
                << "\n"
                );
        }

    uint8_t computeByteForEntity(BigvecOrPageId ent, int64_t byte)
        {
        @match BigvecOrPageId(ent)
            -| Page(p) ->> {
                lassert_dump(
                    mPageDatas[p].size() * sizeof(int64_t) > byte, 
                    "byte " << byte << " greater than size " << mPageDatas[p].size() * sizeof(int64_t)
                    );
                return ((uint8_t*)&mPageDatas[p][0])[byte];
                }
            -| Bigvec(b) ->> {
                auto sliceAndOffset = mBigVectorLayouts[b].sliceAndOffsetContainingIndex(byte);

                int64_t offsetInSlice = byte - sliceAndOffset.second;

                return computeByteForEntity(
                    BigvecOrPageId::Page(sliceAndOffset.first.vector().getPage()),
                    sliceAndOffset.first.slice().low() + offsetInSlice
                    );
                }
        }

    BigvecOrPageId pickRandomEntity()
        {
        if (mRandom() < .5)
            return BigvecOrPageId::Page(mPages[mRandom() * mPages.size()]);
        return BigvecOrPageId::Bigvec(mBigVectorIds[mRandom() * mBigVectorIds.size()]);
        }

    void updateAll()
        {
        bool didAnything = true;
        while (didAnything)
            {
            didAnything = false;

            while (auto task = mPlacements.extractTask())
                {
                mCopyOps++;
                mCopyBytes += task->bytecount();
                didAnything = true;

                task->copy();
                mPlacements.taskComplete(*task);
                }

            while (auto needed = mNeededPageRegions.getNonblock())
                {
                didAnything = true;

                int64_t index = 0;

                int64_t pageBytes = mPageDatas[needed->first].size() * sizeof(int64_t);
                
                lassert_dump(
                    needed->second.high() <= mPageDatas[needed->first].size() * sizeof(int64_t),
                    "Asked for " << prettyPrintString(needed) << " but we only have " << pageBytes
                    );

                //sometimes, we give more than we need
                if (mRandom() < .2)
                    {
                    if (mRandom() < .1)
                        needed->second = IntegerRange(0, pageBytes);
                    else
                        {
                        needed->second.low() = std::max<int64_t>(0, needed->second.low() - mRandom() * mPageSize);
                        needed->second.high() = std::min<int64_t>(pageBytes, needed->second.high() + mRandom() * mPageSize);
                        }
                    }

                LOG_DEBUG << "Handing in " << needed;

                mPlacements.allocatePageData(
                    needed->first, 
                    needed->second, 
                    (uint8_t*)&mPageDatas[needed->first][0] + needed->second.low()
                    );
                }
            }
        }

private:
    int64_t mCopyBytes;

    int64_t mCopyOps;
    
    int64_t mMapOps;
    
    int64_t mAllocOps;
    
    int64_t mPageUploadOps;

    Ufora::math::Random::Uniform<double> mRandom;

    int64_t mBytesPerPage;

    Queue<pair<Fora::PageId, IntegerRange> > mNeededPageRegions;

    OnDemandMemoryRegions mMemoryRegions;

    int64_t mPageSize;

    PageDataPlacements mPlacements;

    std::vector<Fora::PageId> mPages;

    std::map<Fora::PageId, std::vector<int64_t> > mPageDatas;

    std::map<Fora::BigVectorId, BigVectorPageLayout> mBigVectorLayouts;

    std::vector<Fora::BigVectorId> mBigVectorIds;
};


BOOST_AUTO_TEST_CASE( test_PageDataPlacements_random )
	{
    PageDataPlacementsTest test;

    test.touchRandomly(100000);
	}

namespace {

Fora::PageId testPage(int i)
    {
    return Fora::PageId(hash_type(i), 50 * 1024, 50 * 1024);
    }

BigVectorPageLayout testLayout(ImmutableTreeVector<pair<int64_t, IntegerRange> > elts)
    {
    ImmutableTreeVector<VectorDataIDSlice> slices;
    
    for (auto kv: elts)
        slices = slices + 
            VectorDataIDSlice(VectorDataID::Internal(testPage(kv.first), 0), kv.second);


    return BigVectorPageLayout(slices, JudgmentOnResult(JOV::OfType(Type::Integer(8, false))), hashValue(slices));
    }

}

//walk through a sequence of very basic operations, just to make sure its working correctly.
BOOST_AUTO_TEST_CASE( test_PageDataPlacements_basic )
    {
    Queue<pair<Fora::PageId, IntegerRange> > needed;

    OnDemandMemoryRegions memoryRegions(
        //we designed the test suite so that we never actually trigger a page fault - we're trying to call
        //the functions on the PDP directly so that it doesn't happen. If this does happen, it means
        //that a mapping we expected to happen has not occurred.
        [&](OnDemandMemoryRegions::BlockingThread t) { 
            LOG_CRITICAL << "this should never happen.";
            fflush(stdout);
            fflush(stderr);
            _exit(1);
            },
        []() -> void* { return (void*)1; },
        "/ufora"
        );

    int64_t pageSize = memoryRegions.pageSize();
    
    PageDataPlacements placements(
        pageSize,
        [&](PhysicalMemoryAllocation alloc) {
            return memoryRegions.allocateSharedRegion(
                memoryRegions.roundUpToPageSize(alloc.byteRange().size())
                );
            },
        [&](PhysicalMemoryAllocation dealloc, uint8_t* ptr) {
            memoryRegions.freeSharedRegion(ptr);
            },
        [&](uint8_t* sharedBase, uint64_t sharedOffset, uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount) {
            return memoryRegions.mapShareableRegion(sharedBase, sharedOffset, mapBase, mapOffset, bytecount);
            },
        [&](uint8_t* mapBase, uint64_t mapOffset, uint64_t bytecount) {
            return memoryRegions.unmap(mapBase, mapOffset, bytecount);
            },
        [&](Fora::PageId page, IntegerRange range) {
            needed.write(make_pair(page, range));
            },
        1024 * 1024,
        32
        );

    BigvecOrPageId pageId = BigvecOrPageId::Page(testPage(0));

    placements.setMappableAddress(pageId, memoryRegions.allocateMappableRegion(pageSize), pageSize);
        
    uint8_t* pageAddress = placements.getMappableAddress(pageId);

    BOOST_CHECK(pageAddress != 0);

    BOOST_CHECK(!placements.byteIsMapped(pageId, 0));

    auto res = placements.translateMappingAddress(pageAddress, 1);

    BOOST_CHECK(res);
    BOOST_CHECK_EQUAL_CPPML(res->first, pageId);
    BOOST_CHECK_EQUAL(res->second, 1);
    

    placements.markThreadBlockedOn(pageId, 0);

    std::vector<uint8_t> someData;
    someData.resize(pageSize);
    someData[1] = 123;

    placements.allocatePageData(pageId.getPage().page(), IntegerRange(0, someData.size()), &someData[0]);

    auto task = placements.extractTask();
    BOOST_CHECK(task);

    BOOST_CHECK(task->source() == &someData[0]);
    BOOST_CHECK(task->bytecount() == someData.size());
    task->copy();

    placements.taskComplete(*task);
    BOOST_CHECK(!placements.extractTask());
    BOOST_CHECK(placements.byteIsMapped(pageId, 1));
    BOOST_CHECK(pageAddress[1] == 123);

    BigVectorPageLayout layout = testLayout(emptyTreeVec() + make_pair(int64_t(0), IntegerRange(0, pageSize)) + make_pair(int64_t(1), IntegerRange(1,pageSize+1)));

    BigvecOrPageId vecId(BigvecOrPageId::Bigvec(layout.identity()));

    placements.addBigVecPageLayout(layout);

    placements.setMappableAddress(vecId, memoryRegions.allocateMappableRegion(pageSize * 2), pageSize * 2);
    
    uint8_t* bvAddr = placements.getMappableAddress(vecId);

    placements.markThreadBlockedOn(vecId, 1);
    BOOST_CHECK(placements.byteIsMapped(vecId, 1));

    //nothing should need to be copied
    BOOST_CHECK(bvAddr[1] == 123);

    //define the next block
    someData.resize(pageSize * 2);
    someData[1] = 23;
    placements.allocatePageData(testPage(1), IntegerRange(0, someData.size() * 2), &someData[0]);

    placements.markThreadBlockedOn(vecId, pageSize);
    
    while (auto task = placements.extractTask())
        {
        task->copy();
        placements.taskComplete(*task);
        }

    BOOST_CHECK(placements.byteIsMapped(vecId, pageSize));

    BOOST_CHECK_EQUAL((long)bvAddr[pageSize], (long)23);
    }





