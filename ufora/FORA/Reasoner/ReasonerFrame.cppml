/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/

#include "SimpleForwardReasoner.hppml"
#include "../Judgment/ControlFlowGraphJudgmentUtil.hppml"
#include "ReasonerFrame.hppml"
#include "../../core/cppml/CPPMLVisit.hppml"
#include "../../core/Logging.hpp"
#include "../../core/Clock.hpp"
#include "../Axioms/Axiom.hppml"
#include "../Axioms/AxiomGroup.hppml"
#include "JudgmentMerger.hppml"

namespace Fora {

bool ReasonerFrame::NodeRoot::covers(const NodeRoot& root) const
	{
	return ::covers(jovs(), root.jovs());
	}

ReasonerFrame::NodeRoot ReasonerFrame::NodeRoot::rootUnion(const NodeRoot& root) const
	{
	JudgmentMerger merger;

	ImmutableTreeVector<JOV> newJOVs;

	for (long k = 0; k < jovs().size(); k++)
		{
		JOV newJOV = merger.mergeJudgments(jovs()[k], root.jovs()[k]);

		newJOVs = newJOVs + newJOV;
		}

	return NodeRoot(label(), newJOVs);
	}

bool ReasonerFrame::NodeRoot::isTyped() const
	{
	for (auto jov: jovs())
		if (!jov.type())
			return false;
	return true;
	}

bool ReasonerFrame::NodeRoot::hasNoUnknowns() const
	{
	JudgmentMerger merger;

	for (auto jov: jovs())
		if (merger.classMediatorCount(jov).unknownJudgmentsSeen())
			return false;

	return true;
	}

bool ReasonerFrame::Node::hasNoUnknowns() const
	{
	JudgmentMerger merger;

	for (auto jov: jovs())
		if (merger.classMediatorCount(jov).unknownJudgmentsSeen())
			return false;

	return true;
	}

bool ReasonerFrame::Node::isTyped() const
	{
	for (auto jov: jovs())
		if (!jov.type())
			return false;
	return true;
	}

ReasonerFrame::ReasonerFrame(const ReasonerFrameId& frameId, SimpleForwardReasoner& reasoner) :
		mFrameId(frameId),
		mGraphLoopPoints(frameId.entrypoint().graph()),
		mHasExceptions(false),
		mReasoner(reasoner),
		mDisableRecalculation(false),
		mIsMarkedRecursive(false)
	{
	LOG_DEBUG << "Creating new entrypoint " << entrypoint();

	mHash = mFrameId.hash();

	ReasonerEntrypoint entrypoint = frameId.entrypoint();

	if (!entrypoint.applyJOA())
		addRoot(NodeRoot(entrypoint.label(), entrypoint.jovs()));
	else
		{
		//we are an apply node with an incoming value
		auto nodeBody = entrypoint.graph()[entrypoint.label()].body();
		@match ControlFlowNodeBody(nodeBody)
			-| Apply(_, normalCont, exceptionCont) ->> {
				@match ControlFlowContinuation(normalCont)
					-| Node(targetLabel, args) ->> {
						for (auto resJOV: entrypoint.applyJOA()->resultPart().vals())
							{
							ImmutableTreeVector<JOV> jovsToMerge = getJudgment(args, entrypoint.jovs(), null() << resJOV, null() << nodeBody);

							addRoot(NodeRoot(ControlFlowGraphLabel(targetLabel), jovsToMerge));
							}
						}
					-| Return(arg, isException) ->> {
						for (auto resJOV: entrypoint.applyJOA()->resultPart().vals())
							{
							JOV resultJOV = getJudgment(arg, entrypoint.jovs(), null() << resJOV, null() << nodeBody);

							mExits = mExits | (
								isException ?
									JudgmentOnAction::Throws(resultJOV) :
									JudgmentOnAction::Value(resultJOV)
								);
							}
						mDisableRecalculation = true;
						}
				}
			-| Cached(_, normalCont, exceptionCont) ->> {
				@match ControlFlowContinuation(normalCont)
					-| Node(targetLabel, args) ->> {
						for (auto resJOV: entrypoint.applyJOA()->resultPart().vals())
							{
							ImmutableTreeVector<JOV> jovsToMerge = getJudgment(args, entrypoint.jovs(), null() << resJOV, null() << nodeBody);

							addRoot(NodeRoot(ControlFlowGraphLabel(targetLabel), jovsToMerge));
							}
						}
					-| Return(arg, isException) ->> {
						for (auto resJOV: entrypoint.applyJOA()->resultPart().vals())
							{
							JOV resultJOV = getJudgment(arg, entrypoint.jovs(), null() << resJOV, null() << nodeBody);

							mExits = mExits | (
								isException ? 
									JudgmentOnAction::Throws(resultJOV) : 
									JudgmentOnAction::Value(resultJOV)
								);
							}
						mDisableRecalculation = true;
						}
				}
			-| _ ->> {
				lassert_dump(
					false,
					"If an entrypoint has an applyJOA, it should have been created from an apply node. This node is "
						<< prettyPrintString(nodeBody)
						<< "\nwhich is " << prettyPrintString(entrypoint.label()) << " in "
						<< prettyPrintString(entrypoint.graph())
					);
				}
		}
	}

void ReasonerFrame::markIsRecursive()
	{
	mIsMarkedRecursive = true;
	}

bool ReasonerFrame::isMarkedRecursive() const
	{
	return mIsMarkedRecursive;
	}

bool ReasonerFrame::recalculationDisabled() const
	{
	return mDisableRecalculation;
	}

hash_type ReasonerFrame::hash() const
	{
	return mHash;
	}

JudgmentOnAction ReasonerFrame::exits() const
	{
	return mExits;
	}

ControlFlowGraph ReasonerFrame::graph() const
	{
	return mFrameId.entrypoint().graph();
	}

ImmutableTreeVector<JOV> ReasonerFrame::entryJOVs() const
	{
	return mFrameId.entrypoint().jovs();
	}

const MapWithIndex<ReasonerFrame::Node, ReasonerFrameId>&
				ReasonerFrame::getCalledFrames() const
	{
	return mCalledFrames;
	}

void ReasonerFrame::entrypointExitsChanged(const ReasonerFrameId& downstreamEntrypoint)
	{
	lassert(mCalledFrames.hasValue(downstreamEntrypoint));
	for (auto node: mCalledFrames.getKeys(downstreamEntrypoint))
		mDirtyNodes.insert(node.root());
	}

void ReasonerFrame::dirtyAll()
	{
	for (auto& node: mNodes.getKeysToValues())
		mDirtyNodes.insert(node.first);
	}

Nullable<ReasonerFrameId> ReasonerFrame::relaxesTo() const
	{
	return mRelaxesTo;
	}

void ReasonerFrame::markRelaxesTo(ReasonerFrameId frame)
	{
	lassert(!mRelaxesTo);
	lassert(!mDisableRecalculation);
	mRelaxesTo = frame;
	}

void ReasonerFrame::clearUnnecessaryStructuresAfterCompilation()
	{
	mNodes = TwoWaySetMap<NodeRoot, Node>();
	mNodeFlows = TwoWaySetMap<Node, Node>();
	mNodesExiting.clear();
	mNodesWithNonconstAxioms.clear();

	for (auto rootAndLabel: mNodeRoots.getValuesToKeys())
		mNodes.insert(rootAndLabel.first, Node(rootAndLabel.first));
	}

void ReasonerFrame::recalculate()
	{
	mNodeRootIndices.clear();
	mNodeIndices.clear();

	if (mDisableRecalculation)
		{
		mDirtyNodes.clear();
		mPendingRecursiveNodes.clear();
		return;
		}

	if (mRelaxesTo)
		{
		//we're just a passthrough to another node. Clear all of our state
		//and just copy that node's behavior into ourselves

		mDirtyNodes.clear();
		mPendingRecursiveNodes.clear();
		mNodeRoots = TwoWaySetMap<ControlFlowGraphLabel, NodeRoot>();
		mNodes = TwoWaySetMap<NodeRoot, Node>();
		mNodeFlows = TwoWaySetMap<Node, Node>();
		mNodesExiting.clear();
		mCalledFrames.clear();
		mCalledFrameJOAs.clear();
		mNodeExits.clear();
		mNodesWithNonconstAxioms.clear();

		NodeRoot singleRoot(entrypoint().label(), entrypoint().jovs());
		Node singleNode(singleRoot);

		mNodeRoots.insert(singleRoot.label(), singleRoot);
		mNodes.insert(singleRoot, singleNode);

		mCalledFrames.set(singleNode, *mRelaxesTo);
		JudgmentOnAction result = mReasoner.getFrameFor_(*mRelaxesTo)->exits();

		mCalledFrameJOAs.set(make_pair(singleNode, *mRelaxesTo), result);
		mNodeExits[singleRoot] = result;
		mExits = result;

		return;
		}

	LOG_DEBUG << "Calculating " << mFrameId << " with "
		<< mPendingRecursiveNodes.size() << " pending and " << mDirtyNodes.size() << " dirty."
		<< ". exits=" << mExits;

	for (auto pending: mPendingRecursiveNodes)
		addRoot(pending);
	mPendingRecursiveNodes.clear();

	while (mDirtyNodes.size())
		{
		NodeRoot root = *mDirtyNodes.begin();
		mDirtyNodes.erase(root);

		recalculateNodeRoot(root);
		}

	JudgmentOnAction exitJOA;
	for (auto nodeAndExit: mNodeExits)
		exitJOA = exitJOA | nodeAndExit.second;

	JudgmentMerger merger;

	JudgmentOnResult exc = merger.collapseJOR(exitJOA.throwPart());

	if (mHasExceptions)
		exc = JudgmentOnResult(JOV());

	if (exitJOA.resultPart().size() > mReasoner.maxOutputJudgments() ||
				merger.classMediatorCount(exitJOA.resultPart()).unknownJudgmentsSeen())
		{
		JudgmentOnResult res = merger.collapseJORToComplexity(exitJOA.resultPart(), mReasoner.maxOutputJudgments());

			{
			LOGGER_WARN_T log = LOGGER_WARN;
			log << "Collapsing " <<
				exitJOA.resultPart().size() << " output judgments in\n\t" << mFrameId << "\nfrom\n";

			for (auto e: exitJOA.resultPart().vals())
				log << "\t" << prettyPrintStringWithoutWrapping(e) << "\n";

			log << "to " << res;
			}

		mExits = JudgmentOnAction(
			res,
			exc
			);
		}
	else
		{
		mExits = JudgmentOnAction(
			exitJOA.resultPart().removeExtraneousJudgments(),
			exc
			);
		}
	}

void ReasonerFrame::incomingRecursion(ImmutableTreeVector<JOV> entryJOVs)
	{
	lassert(mFrameId.entrypoint().label() == ControlFlowGraphLabel());

	//add a node root
	for (auto& nodeRoot: mNodeRoots.getValues(ControlFlowGraphLabel()))
		if (::covers(nodeRoot.jovs(), entryJOVs))
			return;

	mReasoner.markFrameDirty_(mFrameId);

	LOG_DEBUG << "Frame " << mFrameId << " has incoming recursion of " << entryJOVs;

	mPendingRecursiveNodes.insert(NodeRoot(ControlFlowGraphLabel(), entryJOVs));
	}

void ReasonerFrame::addRoot(NodeRoot root)
	{
	//check if any node root covers this
	for (auto existingRoot: mNodeRoots.getValues(root.label()))
		if (existingRoot.covers(root))
			return;
		else
			{
			lassert(root != existingRoot);
			}


	bool anyHadUnknowns = false;
	for (auto existingRoot: mNodeRoots.getValues(root.label()))
		if (!existingRoot.hasNoUnknowns())
			anyHadUnknowns = true;

	//see if there's a root we can collapse with that preserves type info
	for (auto existingRoot: mNodeRoots.getValues(root.label()))
		{
		auto candidate = existingRoot.rootUnion(root);
		if (candidate.hasNoUnknowns())
			{
			lassert(candidate.covers(existingRoot));
			lassert_dump(
				candidate.covers(root),
				"Union of \n" << prettyPrintStringWithoutWrapping(root)
				<< "\nand\n" << prettyPrintStringWithoutWrapping(existingRoot) << "\nis\n"
				<< prettyPrintStringWithoutWrapping(candidate) << "\nwhich doesn't cover the first one");

			LOG_TEST << "Merged\n\t" << prettyPrintStringWithoutWrapping(existingRoot) 
				<< "\n\t" << prettyPrintStringWithoutWrapping(root) 
				<< "\n\t" << prettyPrintStringWithoutWrapping(candidate)
				;

			insertRoot(candidate);
			return;
			}
		}

	insertRoot(root);

	JudgmentMerger merger;

	long totalComplexity = merger.classMediatorCount(mNodeRoots.getValues(root.label())).allClassMediators().size();

	long rootCount = mNodeRoots.getValues(root.label()).size();

	//collapse if we have too much complexity
	if ((rootCount > (totalComplexity * 2 + 2) || anyHadUnknowns) && rootCount > 1)
		{
		Nullable<NodeRoot> merged;

		for (auto r: mNodeRoots.getValues(root.label()))
			{
			if (!merged)
				merged = r;
			else
				merged = r.rootUnion(*merged);
			}

		//if (SHOULD_LOG_WARN())
			{
			LOGGER_WARN_T log = LOGGER_WARN;

			log << "Collapsing roots for "
				<< mFrameId << ": " << root.label() << ":\n";
			for (auto r: mNodeRoots.getValues(root.label()))
				log << "\t" << prettyPrintStringWithoutWrapping(r) << "\n";
			log << "\n" << "into\n\t" << prettyPrintStringWithoutWrapping(*merged);
			}

		insertRoot(*merged);
		}
		else
	if (rootCount % 10 == 0)
		{
		Nullable<NodeRoot> merged;

		for (auto r: mNodeRoots.getValues(root.label()))
			{
			if (!merged)
				merged = r;
			else
				merged = r.rootUnion(*merged);
			}

		LOGGER_WARN_T log = LOGGER_WARN;

		log << "Lots of roots (" << rootCount << ") are within complexity of " << totalComplexity << ": "
			<< mFrameId << ": " << root.label() << ":\n";
		for (auto r: mNodeRoots.getValues(root.label()))
			log << "\t" << prettyPrintStringWithoutWrapping(r) << "\n";
		log << "\n" << "merged would be\n\t" << prettyPrintStringWithoutWrapping(*merged);
		if (merged->hasNoUnknowns())
			log << "\nmerge had no unknowns.";
		}
	}

void ReasonerFrame::insertRoot(ReasonerFrame::NodeRoot newRoot)
	{
	lassert(!mNodeRoots.hasValue(newRoot));

	//first, remove any roots this covers
	std::set<NodeRoot> existing = mNodeRoots.getValues(newRoot.label());

	for (auto e: existing)
		if (newRoot.covers(e))
			{
			clearNodeRoot(e);
			mNodeExits.erase(e);
			mNodeRoots.dropValue(e);
			mDirtyNodes.erase(e);
			}

	mNodeRoots.insert(newRoot.label(), newRoot);
	mDirtyNodes.insert(newRoot);

	LOG_DEBUG << "Relaxed JOVS of " << mFrameId << ": " << newRoot.label() << " to " << mNodeRoots.getValues(newRoot.label());
	}

const std::set<ReasonerFrame::Node>& ReasonerFrame::unknownApplyNodes() const
	{
	return mUnknownApplyNodes;
	}

void ReasonerFrame::recalculateNodeRoot(ReasonerFrame::NodeRoot root)
	{
	clearNodeRoot(root);
	propagateNode(Node(root));
	}

void ReasonerFrame::clearNodeRoot(ReasonerFrame::NodeRoot root)
	{
	for (auto node: mNodes.getValues(root))
		{
		if (mCalledFrames.hasKey(node))
			{
			auto rp = mCalledFrames.getValue(node);
			mCalledFrameJOAs.discard(make_pair(node, rp));
			}

		mCalledFrames.discard(node);
		mUnknownApplyNodes.erase(node);
		mNodeFlows.dropKey(node);
		mNodesExiting.erase(node);
		mNodesWithNonconstAxioms.erase(node);
		}

	mNodes.dropKey(root);
	mDirtyNodes.erase(root);
	}

ReasonerFrameId ReasonerFrame::getFrameTransition(
									const ReasonerFrameId& caller,
									Nullable<std::string> callLocation,
									const ReasonerEntrypoint& callee
									)
	{
	if (caller.recursion().isNone())
		return ReasonerFrameId(callee, ReasonerRecursionFrame::None());

	@match ReasonerRecursionFrame(caller.recursion())
		-| None() ->> {
			return ReasonerFrameId(callee, ReasonerRecursionFrame::None());
			}
		-| Recursive(recurseBackTo, paths, pathSoFar) ->> {
			auto newPath = pathSoFar + make_pair(callLocation, callee.graph());

			bool anyAreSubstrings = false;
			for (long k = 0; k < paths.size() && !anyAreSubstrings; k++)
				if (paths[k] == newPath)
					{
					//we recursed
					return ReasonerFrameId(
						recurseBackTo,
						ReasonerRecursionFrame::Recursive(recurseBackTo, paths, emptyTreeVec())
						);
					}
					else
				if (paths[k].size() > newPath.size() && newPath == paths[k].slice(0, newPath.size()))
					anyAreSubstrings = true;

			if (anyAreSubstrings)
				return ReasonerFrameId(
					callee,
					ReasonerRecursionFrame::Recursive(recurseBackTo, paths, newPath)
					);

			//we're off the recursion
			return ReasonerFrameId(callee, ReasonerRecursionFrame::None());
			}
	}

const TwoWaySetMap<ReasonerFrame::Node, ReasonerFrame::Node>& ReasonerFrame::getNodeFlows() const
	{
	return mNodeFlows;
	}

void ReasonerFrame::propagateNode(
		const Node& node,
		long pathLength
		)
	{
	if (mNodes.hasValue(node))
		return;

	if (!mNodeRoots.hasValue(node.root()))
		//it's possible that we removed our own root higher up in the propagation
		//code
		return;

	mNodes.insert(node.root(), node);

	if (mNodes.getValues(node.root()).size() % 100 == 0 &&
			mNodes.getValues(node.root()).size() / pathLength > 20)
		LOG_WARN << mFrameId << " with root "
			<< node.root() << " has total of " << mNodes.getValues(node.root()).size() << " in path of length " << pathLength;

	ControlFlowNodeBody nodeBody = mFrameId.entrypoint().graph()[node.label()].body();
	ImmutableTreeVector<JOV> jovs = node.jovs();

	@match ControlFlowNodeBody(nodeBody)
		-| Apply(args, normalCont, exceptionCont) ->> {
			JOVT applyJOVt = getApplyTupleJudgment(args, jovs, null() << nodeBody);

			auto axiomJOA = mReasoner.getAxioms()->axiomJOA(applyJOVt);

			if (!axiomJOA)
				{
				LOG_WARN << "Couldn't find an axiom for " << applyJOVt;
				mUnknownApplyNodes.insert(node);
				mHasExceptions = true;
				return;
				}
			else
				mUnknownApplyNodes.erase(node);

			JudgmentOnAction possibleResults;

			if (mCalledFrames.hasKey(node))
				{
				auto rp = mCalledFrames.getValue(node);
				mCalledFrameJOAs.discard(make_pair(node, rp));
				}

			mCalledFrames.discard(node);

			@match AxiomJOA(*axiomJOA)
				-| Expands() ->> {
					auto axiom = mReasoner.getAxioms()->axiom(mReasoner.getCompiler(), applyJOVt);

					auto cfg = axiom->getExpands().graphGeneratorFunction()(ApplySignature(args));

					ImmutableTreeVector<JOV> childJOVs =
						mapITV(
							args,
							[&](ControlFlowApplyArg arg) -> JOV {
								return getApplyJovJudgment(arg, jovs, null() << nodeBody);
								}
							);

					ReasonerFrameId relaxedEntrypoint = getFrameTransition(
						mFrameId,
						node.label(),
						ReasonerEntrypoint(cfg, ControlFlowGraphLabel(), childJOVs)
						);

					lassert(relaxedEntrypoint.entrypoint().graph() == cfg);

					mCalledFrames.set(node, relaxedEntrypoint);

					auto subframe = mReasoner.getFrameFor_(relaxedEntrypoint);

					if (!subframe)
						return;

					if (mFrameId.recursion().flowIsRecursion(relaxedEntrypoint.recursion()))
						{
						subframe->incomingRecursion(childJOVs);
						}

					possibleResults = subframe->exits();

					mCalledFrameJOAs.set(make_pair(node, relaxedEntrypoint), possibleResults);
					}
				-| Native(result) ->> {
					if (applyJOVt.computeConstant())
						{
						JudgmentOnAction constantResult = mReasoner.getStats()->resolveAxiomDirectly(applyJOVt);
						if (constantResult.size() == 1 && constantResult.jovAndIsExceptionByIndex(0).first.constant())
							possibleResults = constantResult;
						else
							possibleResults = result;
						}
					else
						{
						mNodesWithNonconstAxioms.insert(node);
						possibleResults = result;
						}
					}

			for (auto normalResult: possibleResults.resultPart().vals())
				followContinuation(node, normalCont, jovs, nodeBody, null() << normalResult, pathLength);

			for (auto exceptionResult: possibleResults.throwPart().vals())
				followContinuation(node, exceptionCont, jovs, nodeBody, null() << exceptionResult, pathLength);

			if (possibleResults.throwPart().vals().size())
				mHasExceptions = true;
			}
		-| Cached() ->> {
			mHasExceptions = true;
			return;
			}
		-| Branch(Constant(c), ifTrue, ifFalse) ->> {
			followContinuation(
				node,
				*JOV::Constant(c).convertToBoolean() ? ifTrue : ifFalse,
				jovs,
				nodeBody,
				null(),
				pathLength
				);
			}
		-| Branch(Arg(ix), ifTrue, ifFalse) ->> {
			JOV branchOn = jovs[ix];

			Nullable<bool> which = branchOn.convertToBoolean();
			if (which)
				followContinuation(node, *which ? ifTrue : ifFalse, jovs, nodeBody, null(), pathLength);
			else
				{
				followContinuation(node, ifTrue, jovs, nodeBody, null(), pathLength);
				followContinuation(node, ifFalse, jovs, nodeBody, null(), pathLength);
				}
			}
		-| TupleExpand(argIndex, (arity, exact, contIfMatch), ifNoMatch) ->> {
			JOV jov = jovs[argIndex];

			Nullable<bool> isTuple = jovIsTupleOfArity(jovs[argIndex], arity, exact);

			if (!isTuple || *isTuple)
				followContinuation(node, contIfMatch, jovs, nodeBody, null(), pathLength);

			if (!isTuple || !*isTuple)
				followContinuation(node, ifNoMatch, jovs, nodeBody, null(), pathLength);
			}
		-| Switch(Constant(c), branches, otherwise) ->> {
			if (branches.contains(c))
				followContinuation(node, *branches[c], jovs, nodeBody, null(), pathLength);
			else
				followContinuation(node, otherwise, jovs, nodeBody, null(), pathLength);
			}
		-| Switch(Arg(ix), branches, otherwise) ->> {
			JOV switchOn = jovs[ix];

			Nullable<CSTValue> which = switchOn.constant();

			if (which)
				followContinuation(
					node,
					branches.contains(*which) ? *branches[*which] : otherwise,
					jovs,
					nodeBody,
					null(),
					pathLength
					);
			else
				{
				for (auto branchAndCont: branches)
					if (!switchOn.disjoint(JOV::Constant(branchAndCont.first)))
						followContinuation(
							node,
							branchAndCont.second,
							jovs,
							nodeBody,
							null(),
							pathLength
							);

				followContinuation(node, otherwise, jovs, nodeBody, null(), pathLength);
				}
			}
		-| Jump(c) ->> {
			followContinuation(node, c, jovs, nodeBody, null(), pathLength);
			}
	}

Nullable<ReasonerFrame::NodeRoot> ReasonerFrame::bestRootFor(ControlFlowGraphLabel label, ImmutableTreeVector<JOV> jovs)
	{
	for (auto nr: mNodeRoots.getValues(label))
		if (::covers(nr.jovs(), jovs))
			return null() << nr;

	return null();
	}

bool ReasonerFrame::isMergeNode(ControlFlowGraphLabel label) const
	{
	return mGraphLoopPoints.shouldCollapseJudgmentsAtNode(label);
	}

void ReasonerFrame::followContinuation(
				const Node& path,
				const ControlFlowContinuation& continuation,
				const ImmutableTreeVector<JOV>& jovs,
				const ControlFlowNodeBody& nodeBody,
				const Nullable<JOV>& result,
				long pathLength
				)
	{
	@match ControlFlowContinuation(continuation)
		-| Node(targetLabel, args) ->> {
			ImmutableTreeVector<JOV> jovsToMerge = getJudgment(args, jovs, result, null() << nodeBody);

			LOG_DEBUG << mFrameId.hash() << ": " << path << " with body = " << nodeBody << ", cont= "
				<< continuation
				<< ", and res=" << result
				<< " -> "
				<< (mGraphLoopPoints.shouldCollapseJudgmentsAtNode(null() << targetLabel) ? "root ":"subnode ")
				<< Node(path.root(), ControlFlowGraphLabel(targetLabel), jovsToMerge)
				;

			if (mGraphLoopPoints.shouldCollapseJudgmentsAtNode(null() << targetLabel))
				{
				NodeRoot root(ControlFlowGraphLabel(targetLabel), jovsToMerge);

				addRoot(NodeRoot(ControlFlowGraphLabel(targetLabel), jovsToMerge));
				mNodeFlows.insert(path, Node(root));
				}
			else
				{
				Node node(path.root(), ControlFlowGraphLabel(targetLabel), jovsToMerge);

				propagateNode(node, pathLength+1);
				mNodeFlows.insert(path, node);
				}
			}
		-| Return(arg, isException) ->> {
			if (isException)
				{
				mHasExceptions = true;
				return;
				}

			JOV resultJOV = getJudgment(arg, jovs, result, null() << nodeBody);

			JudgmentOnAction resJOA =
				isException ?
					JudgmentOnAction::Throws(resultJOV) :
					JudgmentOnAction::Value(resultJOV)
					;

			mNodeExits[path.root()] = mNodeExits[path.root()] | resJOA;

			mNodesExiting.insert(path);
			}
	}

const TwoWaySetMap<ReasonerFrame::NodeRoot, ReasonerFrame::Node>& ReasonerFrame::getNodeRootToNodeMap() const
	{
	return mNodes;
	}

const ReasonerEntrypoint& ReasonerFrame::entrypoint() const
	{
	return mFrameId.entrypoint();
	}

const ReasonerFrameId& ReasonerFrame::frameId() const
	{
	return mFrameId;
	}

bool ReasonerFrame::coversEntry(const ReasonerFrame& other) const
	{
	if (mFrameId.entrypoint().label() != ControlFlowGraphLabel() ||
			other.entrypoint().label() != ControlFlowGraphLabel())
		return false;

	if (other.exits() != exits())
		return false;

	if (getNodeRoots().getValues(ControlFlowGraphLabel()) == other.getNodeRoots().getValues(ControlFlowGraphLabel()))
		return frameId() > other.frameId();

	for (auto otherRoot: other.getNodeRoots().getValues(ControlFlowGraphLabel()))
		{
		bool otherHas = false;
		for (auto ownRoot: mNodeRoots.getValues(ControlFlowGraphLabel()))
			if (ownRoot.covers(otherRoot))
				otherHas = true;
		if (!otherHas)
			return false;
		}

	return true;
	}

bool ReasonerFrame::exitsAreConstants() const
	{
	return mExits.throwPart().vals().size() == 0 && mExits.resultPart().vals().size() == 1 &&
		mExits.resultPart().vals()[0].constant();
	}

Nullable<ReasonerFrame::NodeRoot> ReasonerFrame::entrypointRootFor(ImmutableTreeVector<JOV> jovs)
	{
	for (auto& root: mNodeRoots.getValues(ControlFlowGraphLabel()))
		if (::covers(root.jovs(), jovs))
			return null() << root;

	return null();
	}

Nullable<ReasonerFrame::Node> ReasonerFrame::getAnyTypedNodeCovering(ControlFlowGraphLabel label, ImmutableTreeVector<JOV> jovs)
	{
	for (auto& nodeAndRoots: mNodes.getValuesToKeys())
		{
		Node node = nodeAndRoots.first;
		if (mUnknownApplyNodes.find(node) == mUnknownApplyNodes.end() && 
				node.label() == label && ::covers(node.jovs(), jovs))
			return null() << node;
		}

	return null();
	}

int64_t ReasonerFrame::indexOfNodeRoot(const NodeRoot& root)
	{
	if (mNodeRootIndices.size() == 0)
		{
		for (auto& rootAndNodes: mNodes.getKeysToValues())
			{
			int64_t index = mNodeRootIndices.size();
			mNodeRootIndices[rootAndNodes.first] = index;
			}
		}

	return mNodeRootIndices[root];
	}

int64_t ReasonerFrame::indexOfNode(const Node& root)
	{
	if (mNodeIndices.size() == 0)
		{
		for (auto& nodeAndRoots: mNodes.getValuesToKeys())
			{
			int64_t index = mNodeIndices.size() + mNodes.keyCount();
			mNodeIndices[nodeAndRoots.first] = index;
			}
		}

	return mNodeIndices[root];
	}

}