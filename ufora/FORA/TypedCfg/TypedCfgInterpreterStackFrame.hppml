/***************************************************************************
    Copyright 2016 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#pragma once

#include "TypedCfgStats.hppml"
#include "../Native/NativeRuntimeCallbacks.hppml"

class StackFrame;
class StackFrameAllocator;

class TypedCfgInterpreterStackFrame {
public:
    static TypedCfgInterpreterStackFrame* allocate(
                StackFrameAllocator& allocator, 
                NativeRuntimeContinuationValue<2> continuations,
                TypedCfgStats::NodePtr node,
                NativeRuntimeCallbacks* callbacks
                );

    static TypedCfgInterpreterStackFrame* allocate(
                StackFrameAllocator& allocator, 
                TypedCfgInterpreterStackFrame* parent,
                TypedCfgStats::NodePtr node,
                NativeRuntimeCallbacks* callbacks
                );

    static TypedCfgInterpreterStackFrame* allocate(
                StackFrameAllocator& allocator, 
                NativeRuntimeContinuationValue<2> continuations,
                ControlFlowGraph graph,
                ControlFlowGraphLabel label,
                NativeRuntimeCallbacks* callbacks
                );

    static TypedCfgInterpreterStackFrame* allocate(
                StackFrameAllocator& allocator, 
                TypedCfgInterpreterStackFrame* parent,
                ControlFlowGraph graph,
                ControlFlowGraphLabel label,
                NativeRuntimeCallbacks* callbacks
                );

    static void destroy(TypedCfgInterpreterStackFrame* frame, StackFrameAllocator& allocator);

    ImplVal& frameValue(int64_t val) 
        {
        return mFrameValues[val];
        }

    void advanceNodePtrTo(TypedCfgStats::Node* inPtr)
        {
        mGraphAndLabel.reset();
        mTypedCfgNode = inPtr;
        }

    void advanceGraphLabelTo(ControlFlowGraphLabel label)
        {
        lassert(mGraphAndLabel);
        mGraphAndLabel->second = label;
        }

    TypedCfgGraph* getIntendedApplyGraphPtr() const;

    void replaceTypedCfgNodeWithGraphAndLabel()
        {
        mGraphAndLabel.reset(new pair<ControlFlowGraph, ControlFlowGraphLabel>(getGraph(), getLabel()));
        mTypedCfgNode = nullptr;
        }

    TypedCfgInterpreterStackFrame* getParentFrame() const
        {
        return mParentStackFrame;
        }

    ImplVal& getResultValue()
        {
        return mResultValue;
        }

    NativeRuntimeCallbacks* getCallbacks() const
        {
        return mCallbacks;
        }

    TypedCfgStats::NodePtr getNodePtr() const
        {
        return mTypedCfgNode;
        }

    NativeRuntimeContinuationValue<2> getContinuations() const
        {
        lassert(!mParentStackFrame);
        return mContinuations;
        }

    uint32_t currentActiveValueCount() const;

    const ControlFlowGraph& getGraph() const;

    const ControlFlowGraphLabel& getLabel() const;

private:
    TypedCfgInterpreterStackFrame(
            NativeRuntimeContinuationValue<2> conts,
            TypedCfgStats::NodePtr node,
            NativeRuntimeCallbacks* callbacks
            );

    TypedCfgInterpreterStackFrame(
            TypedCfgInterpreterStackFrame* parentPtr,
            TypedCfgStats::NodePtr node,
            NativeRuntimeCallbacks* callbacks
            );

    TypedCfgInterpreterStackFrame(
            NativeRuntimeContinuationValue<2> conts,
            ControlFlowGraph graph,
            ControlFlowGraphLabel label,
            NativeRuntimeCallbacks* callbacks
            );

    TypedCfgInterpreterStackFrame(
            TypedCfgInterpreterStackFrame* parentPtr,
            ControlFlowGraph graph,
            ControlFlowGraphLabel label,
            NativeRuntimeCallbacks* callbacks
            );

    boost::shared_ptr<pair<ControlFlowGraph, ControlFlowGraphLabel> > mGraphAndLabel;

    //one of mContinuations or mParentStackFrame will be populated.
    //mContinuations will be populated for arbitrary callers
    NativeRuntimeContinuationValue<2> mContinuations;

    //in cases where the parent is another TypedCfg frame, however,
    //it's faster to just have the parent stackframe encoded this way, because
    //we know how to communicate the typing information
    TypedCfgInterpreterStackFrame* mParentStackFrame;

    NativeRuntimeCallbacks* mCallbacks;

    TypedCfgStats::Node* mTypedCfgNode;

    //this is a "pooled" implval
    ImplVal mResultValue;

    //the first N values of the stackframe are actually populated, where
    //N is the max number of nodes in the CFG we jump into initially.
    //these are all pooled implvals
    ImplVal mFrameValues[1];
};
