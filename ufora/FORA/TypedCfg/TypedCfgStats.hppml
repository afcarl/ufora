/***************************************************************************
    Copyright 2016 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#pragma once

#include "TypedCfg.hppml"
#include "../Native/NativeFunctionPointerAndEntrypointId.hppml"

namespace TypedFora {

class Compiler;

}

namespace TypedCfgStatsClasses {

class Node;
class ContinuationStats;

typedef Node* NodePtr;

@type ContinuationStats = 
	int64_t timesFollowed
	;

@type 
	NodeBody = 
		-| Apply of
				ImmutableTreeVector<ControlFlowApplyArg> args,
				ApplyTarget target,
				ImmutableTreeVector<Continuation> normal,
				ImmutableTreeVector<Continuation> exception
		-| Cached of 	
				ControlFlowArg args,
				Continuation normal,
				Continuation exception
		-| Branch of 	
				ControlFlowArg arg,
				Continuation normal,
				Continuation exception
		-| TupleExpand of
				uint32_t argIndex,
				TupleContinuation ifMatch,
				Continuation ifNoMatch
		-| Switch of 	
				ControlFlowArg arg,
				ImmutableTreeMap<CSTValue, Continuation> branches,
				Continuation otherwise
		-| Jump of 	
				Continuation continuation
		-| TransferToInterpreter of ()
and
	Node = 
		ControlFlowGraphLabel label,
		ImmutableTreeVector<JOV> judgments,
		NodeBody body
and
	ApplyTarget = 
		-| Graph of NodePtr nodeCache
		-| NativeAxiom of 
				Axiom_NativeType nativeAxiom,
				NativeFunctionPointerAndEntrypointId functionPointer
and
	Continuation =
		-| Return of 
				ControlFlowContinuationArg arg,
				bool isException,
				int32_t indexInExits
		-| Jump of 
				hash_type node_label,
				ImmutableTreeVector<ControlFlowContinuationArg> args,
				NodePtr nodeCache
	with
		boost::shared_ptr<ContinuationStats> stats
and
	TupleContinuation =
		uint32_t arity,
		bool arityIsExact,
		Continuation continuation
		;

}

class TypedCfgStats : public PolymorphicSharedPtrBase<TypedCfgStats> {
public:
	TypedCfgStats(PolymorphicSharedPtr<TypedFora::Compiler> compiler);

	typedef TypedCfgStatsClasses::Node Node;
	typedef TypedCfgStatsClasses::NodeBody NodeBody;
	typedef TypedCfgStatsClasses::Continuation Continuation;
	typedef TypedCfgStatsClasses::ApplyTarget ApplyTarget;
	
	void addGraphSet(ImmutableTreeMap<TypedCfgGraphIdentity, TypedCfgGraph> inGraphSet);

	Node* getNode(TypedCfgGraphIdentity graphId, hash_type nodeHash);

private:
	void addGraph(TypedCfgGraphIdentity curIdentity, const TypedCfgGraph& graph, map<hash_type, Node>& outNodeMap);

	Node convertNode(const TypedCfgNode& node, map<hash_type, TypedCfgStats::Node>& graphNodeMap);

	NodeBody convertNodeBody(const TypedCfgNodeBody& node, map<hash_type, TypedCfgStats::Node>& graphNodeMap);

	Continuation convertContinuation(const TypedCfgContinuation& cont, map<hash_type, TypedCfgStats::Node>& graphNodeMap);

	ApplyTarget convertApplyTarget(const TypedCfgApplyTarget& target);

	mutable boost::mutex mMutex;

	map<TypedCfgGraphIdentity, TypedCfgGraph> mGraphSets;

	map<TypedCfgGraphIdentity, map<hash_type,  Node> > mNodes;

	PolymorphicSharedPtr<TypedFora::Compiler> mCompiler;
};






