/***************************************************************************
    Copyright 2016 Ufora Inc.
 
    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at
 
        http://www.apache.org/licenses/LICENSE-2.0
 
    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#pragma once

#include "TypedCfg.hppml"
#include "../Native/NativeFunctionPointerAndEntrypointId.hppml"
#include "../Core/StackFrameAllocator.hpp"

class Axioms;

namespace TypedFora {

class Compiler;
class TypedJumpTarget;

}

namespace TypedCfgStatsClasses {

class Node;
class ContinuationStats;

typedef Node* NodePtr;
typedef TypedCfgGraph* TypedCfgGraphPtr;

@type ContinuationStats = 
	int64_t timesFollowed
	;

@type 
	NodeBody = 
		-| InvalidNode of ()
		-| Apply of
				ImmutableTreeVector<ControlFlowApplyArg> args,
				ApplyTarget target,
				ImmutableTreeVector<Continuation> normal,
				ImmutableTreeVector<Continuation> exception
		-| Cached of 	
				ControlFlowArg args,
				Continuation normal,
				Continuation exception
		-| Branch of 	
				uint32_t arg,
				Continuation normal,
				Continuation exception
		-| TupleExpand of
				uint32_t argIndex,
				TupleContinuation ifMatch,
				Continuation ifNoMatch
		-| TupleExpandJump of
				uint32_t argIndex,
				uint32_t arity,
				Continuation continuation
		-| Switch of 	
				uint32_t arg,
				ImmutableTreeMap<CSTValue, Continuation> branches,
				Continuation otherwise
		-| Jump of 	
				Continuation continuation
		-| TransferToInterpreter of ()
and
	Node = 
		TypedCfgGraphPtr graphPtr,
		ControlFlowGraphLabel label,
		ImmutableTreeVector<JOV> judgments,
		NodeBody body
and
	ApplyTarget = 
		-| Graph of NodePtr nodeCache
		-| NativeAxiom of 
				//the fully specialized form of the axiom
				Axiom_NativeType nativeAxiom,
				//the non-specialized form of the axiom (e.g. as weak as possible)
				Axiom_NativeType weakNativeAxiom,
				//copy of the function pointer taking 
				NativeFunctionPointerAndEntrypointId functionPointer
and
	Continuation =
		-| Return of 
				ControlFlowContinuationArg arg,
				bool isException,
				int32_t indexInExits
		-| Jump of
				ImmutableTreeVector<ControlFlowContinuationArg> args,
				NodePtr nodeCache
	with
		boost::shared_ptr<ContinuationStats> stats
and
	TupleContinuation =
		uint32_t arity,
		bool arityIsExact,
		Continuation continuation
		;

}

class TypedCfgStats : public PolymorphicSharedPtrBase<TypedCfgStats> {
public:
	TypedCfgStats(
			PolymorphicSharedPtr<TypedFora::Compiler> compiler,
			PolymorphicSharedPtr<Axioms> axioms
			);

	typedef TypedCfgStatsClasses::Node Node;
	typedef TypedCfgStatsClasses::NodeBody NodeBody;
	typedef TypedCfgStatsClasses::Continuation Continuation;
	typedef TypedCfgStatsClasses::ApplyTarget ApplyTarget;
	typedef Node* NodePtr;
	
	void addGraphSet(ImmutableTreeMap<TypedCfgGraphIdentity, TypedCfgGraph> inGraphSet);

	Node* getNode(TypedCfgGraphIdentity graphId, hash_type nodeHash);

	JudgmentOnAction resolveAxiomDirectly(const JudgmentOnValueTuple& jovs);

private:
	TypedFora::TypedJumpTarget compileAxiom(Axiom_NativeType nativeAxiom);

	map<hash_type, JudgmentOnAction>	mResolvedAxiomsCache;

	JudgmentOnAction resolveAxiomDirectlyUncached(const JudgmentOnValueTuple& jovs);

	void addGraph(TypedCfgGraphIdentity curIdentity, const TypedCfgGraph& graph, map<hash_type, Node>& outNodeMap);

	Node convertNode(const TypedCfgGraphIdentity curId, const TypedCfgNode& node, map<hash_type, TypedCfgStats::Node>& graphNodeMap);

	NodeBody convertNodeBody(const TypedCfgNodeBody& node, map<hash_type, TypedCfgStats::Node>& graphNodeMap);

	Continuation convertContinuation(const TypedCfgContinuation& cont, map<hash_type, TypedCfgStats::Node>& graphNodeMap);

	ApplyTarget convertApplyTarget(const TypedCfgApplyTarget& target);

	mutable boost::mutex mMutex;

	map<TypedCfgGraphIdentity, TypedCfgGraph> mGraphs;

	map<TypedCfgGraphIdentity, map<hash_type,  Node> > mNodes;

	PolymorphicSharedPtr<TypedFora::Compiler> mCompiler;

	PolymorphicSharedPtr<Axioms> mAxioms;
};






