/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "GpuDataflowNativeCFG.hppml"

@type ReplaceHaltsWith = NativeExpression targetExpr {
public:
	template<class T>
	Nullable<T> processDown(const T& in, bool& out) const
		{
		return null();
		}
	
	template<class T>
	Nullable<T> processUp(const T& in) const
		{
		return null();
		}

	Nullable<NativeExpression> processDown(const NativeExpression& b, bool& outContinue) const
		{
		@match NativeExpression(b)
			-| Halt() ->> {
				outContinue = false;
				return null() << targetExpr();
				}
			-| _ ->> { }

		return null();
		}
};


@type ThreadStateWriter = int64_t countOfSlots {
public:
	NativeExpression writeValueToThreadStateExpression(
			NativeExpression toWrite,
			NativeExpression threadStatePtr,
			NativeExpression incomingIx
			)
		{
		int64_t slotsUsed = 0;

		Nullable<NativeExpression> res = writeValueToThreadStateExpression(toWrite, threadStatePtr, incomingIx, slotsUsed);

		countOfSlots() = std::max(countOfSlots(), slotsUsed);

		if (!res)
			return NativeExpression::Constant(NativeConstant::Nothing());

		return *res;
		}

	Nullable<NativeExpression> writeValueToThreadStateExpression(
			NativeExpression toWrite,
			NativeExpression threadStatePtr,
			NativeExpression incomingIx,
			int64_t& ioSlotsUsed
			)
		{
		@match NativeType(*toWrite.type())
			-| Nothing() ->> { return null(); }
			-| Integer(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Float(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Pointer() ->> { 
				}
			-| Composite(eltTypes) ->> {
				Nullable<NativeExpression> res;

				//write each value in turn
				for (long k = 0; k < eltTypes.size(); k++)
					{
					auto subres = writeValueToThreadStateExpression(toWrite[k], threadStatePtr, incomingIx, ioSlotsUsed);
					if (subres)
						{
						if (!res)
							res = subres;
						else
							res = *res >> *subres;
						}
					}

				return res;
				}

		//this is a primitive (int, float, pointer)
		auto res = null() << threadStatePtr[ioSlotsUsed].load()[incomingIx]
			//cast as a T*
			.cast(toWrite.type()->ptr(), false)
			//and write into it
			.store(toWrite);
		ioSlotsUsed++;
		
		return res;
		}

	NativeExpression readValueFromThreadStateExpression(
			NativeType type,
			NativeExpression threadStatePtr,
			NativeExpression incomingIx,
			int64_t& ioSlotsUsed
			)
		{
		@match NativeType(type)
			-| Nothing() ->> { return NativeExpression::Constant(NativeConstant::Nothing()); }
			-| Integer(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Float(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Pointer() ->> { 
				}
			-| Composite(eltTypes) ->> {
				ImmutableTreeVector<NativeExpression> res;

				//write each value in turn
				for (long k = 0; k < eltTypes.size(); k++)
					res = res + readValueFromThreadStateExpression(eltTypes[k], threadStatePtr, incomingIx, ioSlotsUsed);

				return NativeExpression::CreateComposite(res);
				}

		//this is a primitive (int, float, pointer)
		auto res = threadStatePtr[ioSlotsUsed].load()[incomingIx]
			//cast as a T*
			.cast(type.ptr(), false)
			.load()
			;

		ioSlotsUsed++;
		
		return res;
		}
};

@type ReplaceLocalityHints = 
		NativeExpression threadStatePtr,
		NativeExpression incomingIx,
		ImmutableTreeVector<NativeBlockID>* exitResumptions,
		ImmutableTreeVector<NativeExpression>* entryResumptionExprs,
		ThreadStateWriter* stateWriter,
		ImmutableTreeSet<NativeVariable> boundAbove
{
public:
	ReplaceLocalityHints withVariableBound(NativeVariable var) const
		{
		ReplaceLocalityHints res = *this;

		res.boundAbove() = res.boundAbove() + var;
		
		return res;
		}

	ReplaceLocalityHints withVariableBound(ImmutableTreeVector<NativeVariable> vars) const
		{
		ReplaceLocalityHints res = *this;

		for (auto var: vars)
			res.boundAbove() = res.boundAbove() + var;
		
		return res;
		}

	template<class T>
	Nullable<T> processDown(const T& in, bool& out) const
		{
		return null();
		}
	
	template<class T>
	Nullable<T> processUp(const T& in) const
		{
		return null();
		}

	NativeExpression processDown(const NativeExpression& b, bool& outContinue) const
		{
		@match NativeExpression(b)
			-| Tagged(_, Generic(name, vars)) ->> {
				if (name == "LocalityHint")
					return replaceLocalityHint(*vars["hint"]);
				}
			-| Let(var, expr, within) ->> {
				outContinue = false;
				NativeExpression tExpr = ::transform(expr, *this);
				NativeExpression tWithin = ::transform(within, withVariableBound(var));

				return NativeExpression::Let(var, tExpr, tWithin);
				}
			-| _ ->> { }

		return b;
		}

	NativeContinuation processDown(const NativeContinuation& b, bool& outContinue) const
		{
		outContinue = false;

		NativeContinuation res = b;
		res.expression() = ::transform(res.expression(), withVariableBound(res.var()));

		return res;
		}

	NativeBlock processDown(const NativeBlock& b, bool& outContinue) const
		{
		outContinue = false;

		NativeBlock res = b;

		res.expression() = ::transform(res.expression(), withVariableBound(res.args()));

		return res;
		}

	NativeExpression replaceLocalityHint(NativeExpression hintExpr) const
		{
		NativeBlockID exitResumption = NativeBlockID::internal();
		NativeBlockID entryResumption = NativeBlockID::internal();

		*exitResumptions() = *exitResumptions() + exitResumption;

		NativeExpression writeStateExpression;
		ImmutableTreeMap<NativeVariable, NativeExpression> readStateExpressions;

		int64_t slotsUsedToWrite = 0;
		int64_t slotsUsedToRead = 0;

		for (auto var: boundAbove())
			{
			auto expr = 
				stateWriter()->writeValueToThreadStateExpression(
					var.expr(),
					threadStatePtr(),
					incomingIx(),
					slotsUsedToWrite
					);

			if (expr)
				writeStateExpression = writeStateExpression >> *expr;

			readStateExpressions = readStateExpressions + 
				var + 
				stateWriter()->readValueFromThreadStateExpression(
					var.type(),
					threadStatePtr(),
					incomingIx(),
					slotsUsedToRead
					);

			lassert(slotsUsedToWrite == slotsUsedToRead);
			}

		NativeExpression resumeExpr = 
			NativeExpression::JumpToResumption(entryResumption, readStateExpressions);

		*entryResumptionExprs() = *entryResumptionExprs() + resumeExpr;


		return NativeExpression::Resumption(
			entryResumption,
			writeStateExpression >>
				NativeExpression::JumpToResumption(exitResumption, emptyTreeMap()),
			NativeExpression::Nothing()
			);
		}
};

GpuDataflowNativeCfg GpuDataflowNativeCfg::convert(const NativeCFG& inCFG)
	{
	NativeCFG originalCFG = inCFG;
	NativeCFG modifiedCFG = inCFG;

	NativeBlock entrypointBlock = *inCFG.blocks()[NativeBlockID::entry()];
	lassert_dump(entrypointBlock.args().size() == 3, prettyPrintString(inCFG));

	//allocate function signature variables
	NativeVariable ptrToClosure = NativeVariable::Temp(entrypointBlock.args()[0].type().ptr());
	NativeVariable ptrToThreadBlockIDs = NativeVariable::Temp(NativeType::int32().ptr());
	NativeVariable ptrToThreadHints = NativeVariable::Temp(NativeType::int64().ptr().ptr());
	NativeVariable ptrToThreadState = NativeVariable::Temp(NativeType::int64().ptr().ptr());
	NativeVariable ptrToIncomingIxVals = NativeVariable::Temp(NativeType::int64().ptr());
	NativeVariable ptrToSharedMemory = NativeVariable::Temp(NativeType::uint8().ptr());
	NativeVariable incomingIx = NativeVariable::Temp(NativeType::int64());
	
	ThreadStateWriter stateWriter;


	//replace each 'LocalityHint' expression with an exit-resume operation
	//and pull out the necessary state to produce the appropriate CFG
	ImmutableTreeVector<NativeBlockID> exitResumptions;
	ImmutableTreeVector<NativeExpression> entryResumptionExprs;

	modifiedCFG = ::transform(
		modifiedCFG, 
		ReplaceLocalityHints(
			ptrToThreadState.expr(),
			incomingIx.expr(),
			&exitResumptions,
			&entryResumptionExprs,
			&stateWriter,
			emptyTreeSet()
			)
		);

	//create the exit continuations - one for each exit
	ImmutableTreeVector<NativeContinuation> exitContinuations;

	for (long k = 0; k < modifiedCFG.returnTypes().size(); k++)
		{
		NativeVariable returnVar = NativeVariable::Temp(modifiedCFG.returnTypes()[k]);

		NativeContinuation cont(
			returnVar,
			ptrToThreadBlockIDs.expr()[incomingIx.expr()].store(
				NativeExpression::Constant(NativeConstant::Int32(k+1))
				) >> 
			stateWriter.writeValueToThreadStateExpression(
				returnVar.expr(), 
				ptrToThreadState.expr(), 
				incomingIx.expr()
				) >>
			NativeExpression::Return(0, NativeExpression::Constant(NativeConstant::Nothing()))
			);

		exitContinuations = exitContinuations + cont;
		}

	NativeExpression invokingExpression = 
		NativeExpression::Call(
			NativeCallTarget::Inline(modifiedCFG, NativeBlockID::entry()),
			exitContinuations,
			emptyTreeVec() + 
				ptrToClosure.expr().load() + 
				NativeExpression::Nothing() + 
				ptrToIncomingIxVals.expr()[incomingIx.expr()].load(),
			emptyTreeVec()
			);

	//for each exit resumption we need a resumption that bails from the system
	//and an incoming handler that checks the current thread block and runs with it
	for (long hintIndex = 0; hintIndex < exitResumptions.size(); hintIndex++)
		{
		int32_t threadBlockIndex = modifiedCFG.returnTypes().size() + 1 + hintIndex;

		invokingExpression = NativeExpression::Resumption(
			exitResumptions[hintIndex],
			invokingExpression,
			ptrToThreadBlockIDs.expr()[incomingIx.expr()].store(
				NativeExpression::Constant(NativeConstant::Int32(threadBlockIndex))
				) >>
			NativeExpression::Return(0, NativeExpression::Constant(NativeConstant::Nothing()))
			);
		invokingExpression = 
			NativeExpression::If(
				ptrToThreadBlockIDs.expr()[incomingIx.expr()].load()
					== NativeExpression::Constant(NativeConstant::Int32(threadBlockIndex)),
				entryResumptionExprs[hintIndex],
				invokingExpression
				);
		}

	NativeBlockID haltResumptionBlockId = NativeBlockID::internal();

	//add a handler for Halts and replace halts with jumps to the handler.
	invokingExpression = 
		NativeExpression::Resumption(
			haltResumptionBlockId,
			invokingExpression,
			ptrToThreadBlockIDs.expr()[incomingIx.expr()].store(
				NativeExpression::Constant(NativeConstant::Int32(-1))
				) >>
			NativeExpression::Return(0, NativeExpression::Constant(NativeConstant::Nothing()))
			);

	invokingExpression = ::transform(
		invokingExpression, 
		ReplaceHaltsWith(NativeExpression::JumpToResumption(haltResumptionBlockId, emptyTreeMap()))
		);

	//produce the final CFG
	NativeCFG newCFG(
		emptyTreeVec() + 
			ptrToClosure + 
			ptrToThreadBlockIDs + 
			ptrToThreadHints + 
			ptrToThreadState + 
			ptrToIncomingIxVals + 
			ptrToSharedMemory + 
			incomingIx,
		invokingExpression
		);

	return GpuDataflowNativeCfg(
		inCFG,
		newCFG,
		0,
		stateWriter.countOfSlots(),
		0
		);
	}

