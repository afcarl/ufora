/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#include "GpuDataflowNativeCFG.hppml"

@type ReplaceHaltsWith = NativeExpression targetExpr {
public:
	template<class T>
	Nullable<T> processDown(const T& in, bool& out) const
		{
		return null();
		}
	
	template<class T>
	Nullable<T> processUp(const T& in) const
		{
		return null();
		}

	Nullable<NativeExpression> processDown(const NativeExpression& b, bool& outContinue) const
		{
		@match NativeExpression(b)
			-| Halt() ->> {
				outContinue = false;
				return null() << targetExpr();
				}
			-| _ ->> { }

		return null();
		}
};


@type ThreadStateWriter = int64_t countOfSlots {
public:
	NativeExpression writeValueToThreadStateExpression(
			NativeExpression toWrite,
			NativeExpression threadStatePtr,
			NativeExpression incomingIx
			)
		{
		int64_t slotsUsed = 0;

		Nullable<NativeExpression> res = writeValueToThreadStateExpression(toWrite, threadStatePtr, incomingIx, slotsUsed);

		countOfSlots() = std::max(countOfSlots(), slotsUsed);

		if (!res)
			return NativeExpression::Constant(NativeConstant::Nothing());

		return *res;
		}

	Nullable<NativeExpression> writeValueToThreadStateExpression(
			NativeExpression toWrite,
			NativeExpression threadStatePtr,
			NativeExpression incomingIx,
			int64_t& ioSlotsUsed
			)
		{
		@match NativeType(*toWrite.type())
			-| Nothing() ->> { return null(); }
			-| Integer(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Float(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Pointer() ->> { 
				}
			-| Composite(eltTypes) ->> {
				Nullable<NativeExpression> res;

				//write each value in turn
				for (long k = 0; k < eltTypes.size(); k++)
					{
					auto subres = writeValueToThreadStateExpression(toWrite[k], threadStatePtr, incomingIx, ioSlotsUsed);
					if (subres)
						{
						if (!res)
							res = subres;
						else
							res = *res >> *subres;
						}
					}

				return res;
				}

		//this is a primitive (int, float, pointer)
		auto res = null() << threadStatePtr[ioSlotsUsed].load()[incomingIx]
			//cast as a T*
			.cast(toWrite.type()->ptr(), false)
			//and write into it
			.store(toWrite);
		ioSlotsUsed++;
		
		return res;
		}

	NativeExpression readValueFromThreadStateExpression(
			NativeType type,
			NativeExpression threadStatePtr,
			NativeExpression incomingIx,
			int64_t& ioSlotsUsed
			)
		{
		@match NativeType(type)
			-| Nothing() ->> { return NativeExpression::Constant(NativeConstant::Nothing()); }
			-| Integer(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Float(bits) ->> { 
				lassert_dump(bits <= 64, 
					"currently our channels are 64 bits. We don't expect any larger integer primitives in cuda code."
					);
				}
			-| Pointer() ->> { 
				}
			-| Composite(eltTypes) ->> {
				ImmutableTreeVector<NativeExpression> res;

				//write each value in turn
				for (long k = 0; k < eltTypes.size(); k++)
					res = res + readValueFromThreadStateExpression(eltTypes[k], threadStatePtr, incomingIx, ioSlotsUsed);

				return NativeExpression::CreateComposite(res);
				}

		//this is a primitive (int, float, pointer)
		auto res = threadStatePtr[ioSlotsUsed].load()[incomingIx]
			//cast as a T*
			.cast(type.ptr(), false)
			.load()
			;

		ioSlotsUsed++;
		
		return res;
		}
};

@type ReplaceLocalityHints = 
		NativeExpression threadStatePtr,
		NativeExpression threadHintPtr,
		NativeExpression incomingIx,
		ImmutableTreeVector<NativeBlockID>* exitResumptions,
		ImmutableTreeVector<NativeExpression>* entryResumptionExprs,
		ThreadStateWriter* stateWriter,
		ThreadStateWriter* hintWriter,
		//what variables are needed to continue calculating AFTER this
		//expression returns a value?
		ImmutableTreeSet<NativeVariable> neededToContinue
{
public:
	ReplaceLocalityHints withNeeded(ImmutableTreeSet<NativeVariable> vars) const
		{
		ReplaceLocalityHints res = *this;

		res.neededToContinue() = vars;
		
		return res;
		}

	template<class T>
	Nullable<T> processDown(const T& in, bool& out) const
		{
		return null();
		}
	
	template<class T>
	Nullable<T> processUp(const T& in) const
		{
		return null();
		}

	//if we're evaluating exprs[0], exprs[1], ..., exprs[n-1], then 
	//we will always need more variables to 'continue' from exprs[0] than from exprs[1]. This is because
	//exprs[0] may use a variable that exprs[1] doesn't. So we traverse in reverse order to build up the
	//needed-vars set.
	pair<ImmutableTreeVector<NativeExpression>, ImmutableTreeSet<NativeVariable> > 
				transformExprSeq(ImmutableTreeVector<NativeExpression> exprs) const
		{
		ImmutableTreeVector<NativeExpression> subs;

		ImmutableTreeSet<NativeVariable> needed = neededToContinue();

		for (long k = ((long)exprs.size())-1; k >= 0; k--)
			{
			subs = ::transform(exprs[k], withNeeded(needed)) + subs;
			needed = needed + exprs[k].freeVariables();
			}

		return make_pair(subs, needed);
		}

	NativeExpression processDown(const NativeExpression& b, bool& outContinue) const
		{
		if (!b.type() && neededToContinue().size())
			{
			outContinue = false;
			return ::transform(b, withNeeded(emptyTreeSet()));
			}

		@match NativeExpression(b)
			-| Tagged(_, Generic(name, vars)) ->> {
				if (name == "LocalityHint")
					{
					outContinue = false;
					return replaceLocalityHint(*vars["hint"]);
					}
				}
			-| CreateComposite(exprs) ->> {
				outContinue = false;
				ImmutableTreeVector<NativeExpression> subs = transformExprSeq(exprs).first;

				return NativeExpression::CreateComposite(subs);
				}
			-| DiscardFirst(e1, e2) ->> {
				outContinue = false;

				NativeExpression te2 = ::transform(e2, *this);
				NativeExpression te1 = ::transform(e1, withNeeded(neededToContinue() + e2.freeVariables()));

				return NativeExpression::DiscardFirst(te1, te2);
				}
			-| Store(e1, e2) ->> {
				outContinue = false;

				NativeExpression te2 = ::transform(e2, *this);
				NativeExpression te1 = ::transform(e1, withNeeded(neededToContinue() + e2.freeVariables()));

				return NativeExpression::Store(te1, te2);
				}
			-| Selector(c, e1, e2) ->> {
				outContinue = false;

				NativeExpression tc = ::transform(c, withNeeded(neededToContinue() + e1.freeVariables() + e2.freeVariables()));
				NativeExpression te2 = ::transform(e2, *this);
				NativeExpression te1 = ::transform(e1, *this);

				return NativeExpression::Selector(tc, te1, te2);
				}
			-| BinaryOp(opcode, e1, e2) ->> {
				outContinue = false;

				NativeExpression te2 = ::transform(e2, *this);
				NativeExpression te1 = ::transform(e1, withNeeded(neededToContinue() + e2.freeVariables()));

				return NativeExpression::BinaryOp(opcode, te1, te2);
				}
			-| ElementAddress(elts, source) ->> {
				outContinue = false;

				NativeExpression tsource = ::transform(source, *this);
				ImmutableTreeVector<NativeExpression> telts = 
					withNeeded(neededToContinue() + source.freeVariables()).transformExprSeq(elts).first;

				return NativeExpression::ElementAddress(telts, tsource);
				}
			-| CallLibraryFunction(target, ret, args, passByPtr, resultPassedAsFirstArgPtr) ->> {
				outContinue = false;

				return NativeExpression::CallLibraryFunction(
					target,
					ret,
					transformExprSeq(args).first,
					passByPtr,
					resultPassedAsFirstArgPtr
					);
				}
			-| Continuations() ->> {
				lassert_dump(false, "these should have been stripped earlier");
				}
			-| If(c, e1, e2, fracTrue) ->> {
				outContinue = false;

				NativeExpression tc = ::transform(c, withNeeded(neededToContinue() + e1.freeVariables() + e2.freeVariables()));
				NativeExpression te2 = ::transform(e2, *this);
				NativeExpression te1 = ::transform(e1, *this);

				return NativeExpression::If(tc, te1, te2, fracTrue);
				}
			-| Let(v, e, within) ->> {
				outContinue = false;

				NativeExpression te = ::transform(e, withNeeded(neededToContinue() + within.freeVariables() - v));
				NativeExpression tWithin = ::transform(within, *this);

				return NativeExpression::Let(v, te, tWithin);
				}
			-| Resumption() ->> {
				lassert_dump(false, "these should not have been created yet");
				}
			-| JumpToResumption() ->> {
				lassert_dump(false, "these should not have been created yet");
				}
			-| Call(target, handlers, args, meta) ->> {
				outContinue = false;

				auto argsAndNeededVars = transformExprSeq(args);

				ImmutableTreeSet<NativeVariable> neededAfterConts = argsAndNeededVars.second;

				auto tHandlers = mapITV(handlers, [&](const NativeContinuation& c) {
					neededAfterConts = neededAfterConts + c.freeVariables();

					return ::transform(c, withNeeded(argsAndNeededVars.second));
					});

				return NativeExpression::Call(
					::transform(target, withNeeded(neededAfterConts)),
					tHandlers,
					argsAndNeededVars.first,
					meta
					);
				}
			-| Jump(target, expressions) ->> {
				outContinue = false;
				return NativeExpression::Jump(target, transformExprSeq(expressions).first);
				}
			-| FollowContinuation(var, cont, ix) ->> {
				outContinue = false;
				return NativeExpression::FollowContinuation(
					::transform(var, withNeeded(neededToContinue() + cont.freeVariables())),
					::transform(cont, *this),
					ix
					);
				}
			-| _ ->> { }

		return b;
		}

	NativeExpression replaceLocalityHint(NativeExpression hintExpr) const
		{
		NativeBlockID exitResumption = NativeBlockID::internal();
		NativeBlockID entryResumption = NativeBlockID::internal();

		*exitResumptions() = *exitResumptions() + exitResumption;

		NativeExpression writeStateExpression;
		ImmutableTreeMap<NativeVariable, NativeExpression> readStateExpressions;

		int64_t slotsUsedToWrite = 0;
		int64_t slotsUsedToRead = 0;

		for (auto var: neededToContinue())
			{
			auto expr = 
				stateWriter()->writeValueToThreadStateExpression(
					var.expr(),
					threadStatePtr(),
					incomingIx(),
					slotsUsedToWrite
					);

			if (expr)
				writeStateExpression = writeStateExpression >> *expr;

			readStateExpressions = readStateExpressions + 
				var + 
				stateWriter()->readValueFromThreadStateExpression(
					var.type(),
					threadStatePtr(),
					incomingIx(),
					slotsUsedToRead
					);

			lassert(slotsUsedToWrite == slotsUsedToRead);
			}

		NativeVariable hintVar = NativeVariable::Temp(*hintExpr.type());

		writeStateExpression = writeStateExpression >> 
			NativeExpression::Let(hintVar, hintExpr,
				hintWriter()->writeValueToThreadStateExpression(
					hintVar.expr(),
					threadHintPtr(),
					incomingIx()
					)
				);

		NativeExpression resumeExpr = 
			NativeExpression::JumpToResumption(entryResumption, readStateExpressions);

		*entryResumptionExprs() = *entryResumptionExprs() + resumeExpr;


		return NativeExpression::Resumption(
			entryResumption,
			writeStateExpression >>
				NativeExpression::JumpToResumption(exitResumption, emptyTreeMap()),
			NativeExpression::Nothing()
			);
		}
};

GpuDataflowNativeCfg GpuDataflowNativeCfg::convert(const NativeCFG& inCFG)
	{
	NativeCFG originalCFG = inCFG;
	NativeCFG modifiedCFG = inCFG;

	NativeBlock entrypointBlock = *inCFG.blocks()[NativeBlockID::entry()];
	lassert_dump(entrypointBlock.args().size() == 3, prettyPrintString(inCFG));

	//allocate function signature variables
	NativeVariable ptrToClosure = NativeVariable::Temp(entrypointBlock.args()[0].type().ptr());
	NativeVariable ptrToThreadBlockIDs = NativeVariable::Temp(NativeType::int32().ptr());
	NativeVariable ptrToThreadHints = NativeVariable::Temp(NativeType::int64().ptr().ptr());
	NativeVariable ptrToThreadState = NativeVariable::Temp(NativeType::int64().ptr().ptr());
	NativeVariable ptrToIncomingIxVals = NativeVariable::Temp(NativeType::int64().ptr());
	NativeVariable ptrToSharedMemory = NativeVariable::Temp(NativeType::uint8().ptr());
	NativeVariable incomingIx = NativeVariable::Temp(NativeType::int64());
	
	ThreadStateWriter stateWriter;
	ThreadStateWriter hintWriter;

	//replace each 'LocalityHint' expression with an exit-resume operation
	//and pull out the necessary state to produce the appropriate CFG
	ImmutableTreeVector<NativeBlockID> exitResumptions;
	ImmutableTreeVector<NativeExpression> entryResumptionExprs;

	modifiedCFG = ::transform(
		modifiedCFG, 
		ReplaceLocalityHints(
			ptrToThreadState.expr(),
			ptrToThreadHints.expr(),
			incomingIx.expr(),
			&exitResumptions,
			&entryResumptionExprs,
			&stateWriter,
			&hintWriter,
			emptyTreeSet()
			)
		);

	//create the exit continuations - one for each exit
	ImmutableTreeVector<NativeContinuation> exitContinuations;

	for (long k = 0; k < modifiedCFG.returnTypes().size(); k++)
		{
		NativeVariable returnVar = NativeVariable::Temp(modifiedCFG.returnTypes()[k]);

		NativeContinuation cont(
			returnVar,
			ptrToThreadBlockIDs.expr()[incomingIx.expr()].store(
				NativeExpression::Constant(NativeConstant::Int32(k+1))
				) >> 
			stateWriter.writeValueToThreadStateExpression(
				returnVar.expr(), 
				ptrToThreadState.expr(), 
				incomingIx.expr()
				) >>
			NativeExpression::Return(0, NativeExpression::Constant(NativeConstant::Nothing()))
			);

		exitContinuations = exitContinuations + cont;
		}

	NativeExpression invokingExpression = 
		NativeExpression::Call(
			NativeCallTarget::Inline(modifiedCFG, NativeBlockID::entry()),
			exitContinuations,
			emptyTreeVec() + 
				ptrToClosure.expr().load() + 
				NativeExpression::Nothing() + 
				ptrToIncomingIxVals.expr()[incomingIx.expr()].load(),
			emptyTreeVec()
			);

	//for each exit resumption we need a resumption that bails from the system
	//and an incoming handler that checks the current thread block and runs with it
	for (long hintIndex = 0; hintIndex < exitResumptions.size(); hintIndex++)
		{
		int32_t threadBlockIndex = modifiedCFG.returnTypes().size() + 1 + hintIndex;

		invokingExpression = NativeExpression::Resumption(
			exitResumptions[hintIndex],
			invokingExpression,
			ptrToThreadBlockIDs.expr()[incomingIx.expr()].store(
				NativeExpression::Constant(NativeConstant::Int32(threadBlockIndex))
				) >>
			NativeExpression::Return(0, NativeExpression::Constant(NativeConstant::Nothing()))
			);
		invokingExpression = 
			NativeExpression::If(
				ptrToThreadBlockIDs.expr()[incomingIx.expr()].load()
					== NativeExpression::Constant(NativeConstant::Int32(threadBlockIndex)),
				entryResumptionExprs[hintIndex],
				invokingExpression
				);
		}

	NativeBlockID haltResumptionBlockId = NativeBlockID::internal();

	//add a handler for Halts and replace halts with jumps to the handler.
	invokingExpression = 
		NativeExpression::Resumption(
			haltResumptionBlockId,
			invokingExpression,
			ptrToThreadBlockIDs.expr()[incomingIx.expr()].store(
				NativeExpression::Constant(NativeConstant::Int32(-1))
				) >>
			NativeExpression::Return(0, NativeExpression::Constant(NativeConstant::Nothing()))
			);

	invokingExpression = ::transform(
		invokingExpression, 
		ReplaceHaltsWith(NativeExpression::JumpToResumption(haltResumptionBlockId, emptyTreeMap()))
		);

	//produce the final CFG
	NativeCFG newCFG(
		emptyTreeVec() + 
			ptrToClosure + 
			ptrToThreadBlockIDs + 
			ptrToThreadHints + 
			ptrToThreadState + 
			ptrToIncomingIxVals + 
			ptrToSharedMemory + 
			incomingIx,
		invokingExpression
		);

	return GpuDataflowNativeCfg(
		inCFG,
		newCFG,
		0,
		stateWriter.countOfSlots(),
		hintWriter.countOfSlots()
		);
	}

