/***************************************************************************
    Copyright 2016 Ufora Inc.

    Licensed under the Apache License, Version 2.0 (the "License");
    you may not use this file except in compliance with the License.
    You may obtain a copy of the License at

        http://www.apache.org/licenses/LICENSE-2.0

    Unless required by applicable law or agreed to in writing, software
    distributed under the License is distributed on an "AS IS" BASIS,
    WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
    See the License for the specific language governing permissions and
    limitations under the License.
****************************************************************************/

#pragma once

#include <string>
#include <boost/thread.hpp>
#include "../Core/ImplValContainer.hppml"
#include "../../core/PolymorphicSharedPtr.hpp"
#include "../Native/NativeCode.hppml"
#include "../Native/NativeType.hppml"
#include "../Core/Type.hppml"
#include "../Judgment/JudgmentOnValue.hppml"
    
/***********
GpuDataflowNativeCfg

Wraps a NativeCFG that implements a dataflow-graph version of a given NativeCFG
that contains locality hints.

All valid CFGs start in the form

    f(closure c, int64_t ix) [r1, ..., rR]

where 'f' is computing a function of 'ix' and which can return through one of
the 'r' control flow paths. The initial NativeCFG must be valid for direct translation
to PTX (in the obvious way).  Execution semantics are to compute [f(x) for x in xrange(...)]
for some valid set of integers 'ix'. The in1* to inN* model the closure of 'f'.

For execution purposes on PTX, we transform it to something of the form

    f(closure* c, int32_t* thread_block, int64_t** thread_hints, int64_t** thread_state, int64_t* indices, uint8_t* shared_memory_ptr, ix) [r0]

in this form
    the closure is unchanged - just passed as a pointer.

    thread_block is an integer identifying which portion of the CFG this thread is executing
        -1 means 'exited invalidly' (e.g. we hit a 'halt'). Execution cannot continue.
        0 means 'entrypoint'. This is the initial state. State is empty.
        1-R means 'exited in return-pathway r1 through rR'. thread_state contains the written value
        > R is an internal state (e.g. not exited). thread_state contains a serialized form of the variables in scope
    thread_hints: pointer to thread hints about how threads should be grouped.
    	the execution model assumes that upon execution, each GPU block of threads contains
    	threads starting from the same 'thread_block' value and with the same hint. This allows
    	for coordinated access to the shared_memory.

    	each thread assumes it accesses it as
    		thread_hint[hint_channel][ix]

    thread_state: representation of output values or stackframes. Each thread gets to store whatever it wants in 
    		thread_state[channel][ix]
    	for 'channel' in 1 to channel_N. We do this rather than giving each thread contiguous memory
    	to store state in because we want the threads to write contiguous memory if possible.
    indices*
    	contains the values of 'ix' we are operating on
    ix
		which index in 'indices*' we want to operate on. E.g. call our original 'f' with indices[ix]
		as the index variable. This controls how we reshuffle 

********************/

@type GpuDataflowNativeCfg = 
	NativeCFG originalCFG,
	NativeCFG convertedCFG,
	int64_t bytesOfSharedMemoryRequired,
	int64_t stackDataChannels, //across all return types and intermediates, how many channels do we need in total.
	int64_t threadHintChannels //how many thread hint channels do we need?
{
public:
	static GpuDataflowNativeCfg convert(const NativeCFG& inCFG);

	//the types of r1 through rR
	ImmutableTreeVector<NativeType> exitNativeTypes() const;
};


