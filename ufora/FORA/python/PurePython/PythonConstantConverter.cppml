/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include "PythonConstantConverter.hppml"
#include "PythonConstantType.hppml"
#include "../../Judgment/JudgmentOnValue.hppml"
#include "../../Core/CSTValue.hppml"
#include "../../TypedFora/ABI/VectorRecord.hpp"
#include "../../Core/ImplValContainerUtilities.hppml"
#include "../../Core/MemoryPool.hpp"
#include "../../Language/FunctionStage1Simulation.hppml"

namespace Fora {

PythonConstantConverter::PythonConstantConverter(
                const ImmutableTreeMap<PythonConstantType, ImplValContainer>& primitiveTypeMapping,
                MemoryPool* targetPool
                ) : 
        mTypeConvertersMap(primitiveTypeMapping),
        mTargetMemoryPool(targetPool)
    {
    mStringPrototype = simulateClassInstantiation(
        *mTypeConvertersMap[PythonConstantType::String()], 
        ImplValContainerUtilities::createString(String())
        );
    mIntPrototype = simulateClassInstantiation(
        *mTypeConvertersMap[PythonConstantType::Int()], 
        ImplValContainerUtilities::createSignedInteger(0)
        );
    mBoolPrototype = simulateClassInstantiation(
        *mTypeConvertersMap[PythonConstantType::Boolean()], 
        ImplValContainerUtilities::createBool(false)
        );
    mNonePrototype = simulateClassInstantiation(
        *mTypeConvertersMap[PythonConstantType::None()], 
        ImplValContainer()
        );
    mFloatPrototype = simulateClassInstantiation(
        *mTypeConvertersMap[PythonConstantType::Float()], 
        ImplValContainerUtilities::createDouble(0.0)
        );

    mPrototypeTypeToWrappedType[mStringPrototype.type().hash()] = Type::String();
    mPrototypeTypeToWrappedType[mIntPrototype.type().hash()] = Type::Integer(64, true);
    mPrototypeTypeToWrappedType[mBoolPrototype.type().hash()] = Type::Integer(1, false);
    mPrototypeTypeToWrappedType[mFloatPrototype.type().hash()] = Type::Float(64);
    }

ImplValContainer
PythonConstantConverter::simulateClassInstantiation(
        const ImplValContainer& classImplVal, 
        const ImplValContainer& memberImplVal
        ) const
    {
    FunctionStage1::Simulation simulation(10);

    ImmutableTreeVector<ImplValContainer> applyArgs;

    applyArgs = applyArgs + classImplVal;
    applyArgs = applyArgs +
        ImplValContainerUtilities::createSymbol(Symbol("CreateInstance"));
    applyArgs = applyArgs + memberImplVal;

    auto res = simulation.evaluateApply(applyArgs);

    lassert(res.isResult());

    return res.getResult().val();
    }

ImplValContainer PythonConstantConverter::convertBoolean(uint8_t value) const
    {
    return ImplValContainer(ImplVal(mBoolPrototype.type(), &value));
    }

ImplValContainer PythonConstantConverter::convertInt(int64_t value) const
    {
    return ImplValContainer(ImplVal(mIntPrototype.type(), &value));
    }

ImplValContainer PythonConstantConverter::convertString(const std::string& str) const
    {
    // we might want to move this MemoryPool away from
    // the FreeStore and into a VDM eventually
    ImplValContainer strImplVal =
        ImplValContainerUtilities::createString(
            String(str, mTargetMemoryPool)
            );

    return ImplValContainer(ImplVal(mStringPrototype.type(), strImplVal.data()));
    }

ImplValContainer PythonConstantConverter::convertLong(const std::string&) const
    {
    throw std::logic_error("Conversion of Python 'long' is not supported");
    }

ImplValContainer PythonConstantConverter::noneValue() const
    {
    return mNonePrototype;
    }

ImplValContainer PythonConstantConverter::convertFloat(double value) const
    {
    return ImplValContainer(ImplVal(mFloatPrototype.type(), &value));
    }

Nullable<ImplValContainer> PythonConstantConverter::unwrapToPrimitive(const ImplValContainer& value) const
    {
    Nullable<ImplVal> res = unwrapToPrimitiveRaw(value);
    if (res.isValue()) {
        return null() << ImplValContainer(*res);
        }

    return null();
    }

Nullable<ImplVal> PythonConstantConverter::unwrapToPrimitiveRaw(const ImplValContainer& value) const
    {
    Nullable<ImplVal> primitiveOrNull = unwrapToPrimitiveByPrototypesRaw(value);
    if (primitiveOrNull.isValue()) {
        return primitiveOrNull;
        }

    Nullable<pair<ImplVal, Nullable<Symbol>>> member =
                ImplValContainerUtilities::objectGetMemberRaw(value, Symbol("@m"));

    if (!member || member->second)
        return null();

    @match Type(member->first.type())
        -| Vector() ->> {
            JudgmentOnResult jor = member->first.cast<TypedFora::Abi::VectorRecord>().jor();

            if (jor.size() != 1)
                return null();

            if (jor[0] != JOV::OfType(Type::Integer(8, false)))
                return null();
            }
        -| String() ->> {}
        -| Float(bits) ->> { if (bits != 64) return null(); }
        -| Integer(bits, isSigned) ->> { if (!(bits == 64 && isSigned || bits == 1 && !isSigned)) return null(); }
        -| Nothing() ->> {}
        -| _ ->> {
            return null();
            }

    return null() << member->first;
    }


Nullable<ImplValContainer> PythonConstantConverter::unwrapToPrimitiveByPrototypes(
        const ImplValContainer& value
        ) const
    {
    Nullable<ImplVal> res = unwrapToPrimitiveByPrototypesRaw(value);

    if (res.isValue()) {
        return null() << ImplValContainer(*res);
        }

    return null();
    }


Nullable<ImplVal> PythonConstantConverter::unwrapToPrimitiveByPrototypesRaw(
        const ImplValContainer& value
        ) const
    {
    if (value.type() == noneValue().type()) {
        return null() << ImplVal();
        }

    auto it = mPrototypeTypeToWrappedType.find(value.type().hash());

    if (it != mPrototypeTypeToWrappedType.end()) {
        return null() << ImplVal(it->second, value.data());
        }

    return null();
    }


}

