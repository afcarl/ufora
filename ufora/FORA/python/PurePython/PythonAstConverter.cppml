/***************************************************************************
   Copyright 2015 Ufora Inc.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
****************************************************************************/
#include <unordered_map>
#include "PythonAstConverter.hppml"
#include "PythonListConverter.hppml"
#include "PythonTupleConverter.hppml"
#include "PythonDictConverter.hppml"
#include "PythonToForaConversionError.hppml"
#include "PythonConstantConverter.hppml"
#include "../../Judgment/JudgmentOnValue.hppml"
#include "../../Core/ImplValContainerUtilities.hppml"
#include "../../Language/FunctionStage1Simulation.hppml"
#include "../../Language/ExpressionLocationMetadata.hppml"
#include "../../../core/cppml/CPPMLVisit.hppml"
#include "../../../core/cppml/CPPMLTransform.hppml"
#include "../../../core/Logging.hpp"
#include "../../Language/RebindFree.hppml"
#include "../../Language/ParserExpressions.hppml"
#include "../../Language/ClassMediatorBindings.hppml"


constexpr auto PYFORA_CONVERSION_ERROR_MESSAGE =
    "Pyfora can't convert this code. "
    "See http://docs.pyfora.com/en/latest/tutorials/intro.html#pure-python";

constexpr auto __inline_fora_string = "__inline_fora";


namespace {

using namespace Fora;

using SetOfStringPairs = std::set<std::pair<std::string, std::string>>;

constexpr char MEMBERS_TUPLE_NAME[] = "@m";

void assertValidNameIdentifier(
        const std::string& identifier,
        const SimpleParseRange& extent
        )
    {
    if (identifier == __inline_fora_string)
        throw PythonToForaConversionError(
            std::string("in pyfora, ") + __inline_fora_string +
            " is a reserved word and expects a single argument "
            "string which defines an \"inline\" fora function",
            extent
            );
    }

//take a member name (e.g. 'x') and return the private form of the name (the
//name used by generated code) that refers to it. We use a space because it cannot
//conflict with the names produced by actual python code.
std::string publicDataMemberNameToPrivate(std::string name)
    {
    return "@" + name;
    }

ObjectDefinitionTerm noncapturingObjectMember(std::string name, Expression expr)
    {
    return
        ObjectDefinitionTerm::Anything(
            Function::Term(
                TuplePattern(
                    emptyTreeVec() +
                        TuplePatternElement::Normal(
                            PatternWithName::Constant(
                                CSTValue(Symbol("Member"))
                                )
                            ) +
                        TuplePatternElement::Normal(
                            PatternWithName::Constant(
                                CSTValue(Symbol(name))
                                )
                            )
                    ),
                expr,
                Function::Empty()
                )
            );
    }

ClassDefinitionTerm
createInvalidNumberOfArgumentsClassDefinitionTerm(const std::string& name) {
    return ClassDefinitionTerm::ObjectTerm(
        ObjectDefinitionTerm::Member(
            Symbol(name),
            Expression::Throw(
                Expression::Constant(
                    CSTValue(name + "() takes no arguments; more than one given")
                    ),
                null()
                ),
            1
            )
        );
    }

class AssertOnlySimpleInitStatementsVisitor {
private:
    const std::string& mSelfName;
public:
    AssertOnlySimpleInitStatementsVisitor(const std::string& inSelfName) :
        mSelfName(inSelfName)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        if (expr.isYield())
            throw PythonToForaConversionError(
                "Yield is not supported in __init__ methods",
                expr.extent()
                );
        }

    void processDown(const PythonAstStatement& stmt, bool& outContinue)
        {
        if (stmt.isFunctionDef() or stmt.isClassDef())
            throw PythonToForaConversionError(
                "don't know how to handle function or class definitions in __init__ methods",
                stmt.extent()
                );

        if (stmt.isFunctionDef() or stmt.isReturn())
            throw PythonToForaConversionError(
                "Return statements are currently not supported in __init__ methods",
                stmt.extent()
                );

        if (stmt.isAssign()) {
            if (stmt.getAssign().targets().size() != 1)
                throw PythonToForaConversionError(
                    "don't know how to handle multiple assignment in __init__ methods",
                    stmt.extent()
                    );

            PythonAstExpr target = stmt.getAssign().targets()[0];

            if (target.isName()) {
                if (target.getName().id() == mSelfName) {
                    std::ostringstream oss;
                    oss << "don't know how to handle reassignments to self variable `"
                        << mSelfName << "' in __init__ methods";
                    throw PythonToForaConversionError(
                        oss.str(), stmt.extent()
                        );
                    }
                }
            }
        }
};

class AssertNoStraySelfArgsInTransformedInitBodyVisitor {
private:
    const std::string& mSelfName;
public:
    AssertNoStraySelfArgsInTransformedInitBodyVisitor(
            const std::string& inSelfName
            ) :
        mSelfName(inSelfName)
    {
    }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Name(id, ctx) ->> {
                if (id == mSelfName)
                    throw PythonToForaConversionError(
                        "in pyfora __init__ methods, the self arg can "
                        "only appear in setattr or getattr expressions.",
                        expr.extent()
                        );
                }
            -| Call(func, args, keywords, starargs, kwargs) ->> {
                // The ONLY place we allow 'self' to appear is as the first argument
                // to __init__ calls
                @match PythonAstExpr(func)
                    -| Attribute(value, attr, ctx) ->> {
                        outContinue = (attr != "__init__") || (args.size() == 0) ||
                            !args[0].isName() || (args[0].getName().id() != mSelfName);
                        }
                    -| _ ->> {}
                }
            -| _ ->> {}
            ;
        }
    };


template<class T>
void assertNoStraySelfArgsInTransformedInitBody(
        const T& t,
        const std::string& selfName
        )
    {
    AssertNoStraySelfArgsInTransformedInitBodyVisitor visitor(selfName);

    visit(t, visitor);
    }


class HasYieldFunctionBodyVisitor {
private:
    bool& mHasYield;
public:
    HasYieldFunctionBodyVisitor(
                bool& inHasYield
                ):
            mHasYield(inHasYield)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Yield(id, _) ->> {
                mHasYield = true;
                }
            -| Lambda() ->> { outContinue = false; }
            -| GeneratorExp() ->> { outContinue = false; }
            -| _ ->> {}
            ;
        }

    void processDown(const PythonAstStatement& expr, bool& outContinue)
        {
        @match PythonAstStatement(expr)
            -| FunctionDef() ->> {
                outContinue = false;
                }
            -| ClassDef() ->> {
                outContinue = false;
                }
            -| _ ->> {}
            ;
        }

};

template<class T>
bool hasYield(const T& value)
    {
    bool result = false;

    HasYieldFunctionBodyVisitor visitor(result);

    visit(value, visitor);

    return result;
    }


class ExtractVariablesReferencedInFunctionBodyVisitor {
private:
    std::set<std::string>& mReferencedVariables;
public:
    ExtractVariablesReferencedInFunctionBodyVisitor(
            std::set<std::string>& inReferencedVariables
            ): mReferencedVariables(inReferencedVariables)
        {
        }

    template<class T> void processDown(const T&, bool&) {}
    template<class T> void processUp(const T&) {}

    void processDown(const PythonAstExpr& expr, bool& outContinue)
        {
        @match PythonAstExpr(expr)
            -| Name(id, _) ->> {
                mReferencedVariables.insert(id);
                }
            -| _ ->> {}
            ;
        }
};


class RewriteSelfSetAttrsTransformer {
private:
    SetOfStringPairs& mSelfSetItemMap;
    const std::set<std::string>& mReferencedVariables;
    const std::string& mSelfName;
public:
    RewriteSelfSetAttrsTransformer(
            SetOfStringPairs& inSelfSetItemMap,
            const std::set<std::string>& inReferencedVariables,
            const std::string& selfName
            ):
        mSelfSetItemMap(inSelfSetItemMap),
        mReferencedVariables(inReferencedVariables),
        mSelfName(selfName)
        {
        }

    template<class T>
    Nullable<T> processDown(const T& t, bool& b) const
        {
        return null();
        }

    template<class T>
    Nullable<T> processUp(const T& t) const
        {
        return null();
        }

    Nullable<PythonAstExpr> processDown(
            const PythonAstExpr& expr, bool& ioContinue
            ) const
        {
        @match PythonAstExpr(expr)
            -| Attribute(value, attr, ctx) ->> {
                if (!value.isName() or
                    value.getName().id() != mSelfName)
                    return null();

                std::string replacingName = getReplacingName(
                    attr
                    );

                mSelfSetItemMap.insert(
                    std::make_pair(
                        attr,
                        replacingName
                        )
                    );

                return null() <<
                    PythonAstExpr::Name(
                        replacingName,
                        ctx
                        );
                }
            -| _ ->> { return null(); }
        }

private:
    std::string getReplacingName(const std::string& attrName) const
        {
        std::string tr = mSelfName + "_" + attrName;
        while (mReferencedVariables.find(tr) != mReferencedVariables.end())
            {
            tr = tr + "_";
            }
        return tr;
        }
};

Expression makeCreateInstanceCall(
        const std::string& membersTupleName,
        const std::string& className
        )
    {
    ImmutableTreeVector<ApplyArgument> arguments;

    arguments = arguments +
        ApplyArgument::Normal(
            null(),
            Expression::Constant(
                CSTValue(
                    Symbol("CreateInstance")
                    )
                )
            );

    arguments = arguments + ApplyArgument::Normal(
            null() << Symbol(MEMBERS_TUPLE_NAME),
            Expression::Apply(
                Expression::Constant(CSTValue(Symbol("tupleSortAndDedupNames"))),
                emptyTreeVec() +
                    Expression::Constant(CSTValue(Symbol("Call"))) +
                    Expression::Variable(Symbol(membersTupleName))
                )
            );

    return Expression::Apply(
        Expression::Variable(
            Symbol(className)
            ),
        arguments
        );
    }

void assertOnlySimpleInitStatements(
        const ImmutableTreeVector<PythonAstStatement>& functionBody,
        const std::string& inSelfName
        )
    {
    AssertOnlySimpleInitStatementsVisitor visitor(inSelfName);
    visit(functionBody, visitor);
    }

std::set<std::string> extractVariablesReferencedInFunctionBody(
        const ImmutableTreeVector<PythonAstStatement>& functionBody
        )
    {
    std::set<std::string> referencedVariables;
    ExtractVariablesReferencedInFunctionBodyVisitor visitor(referencedVariables);
    visit(functionBody, visitor);
    return referencedVariables;
    }

std::pair<ImmutableTreeVector<PythonAstStatement>, SetOfStringPairs>
rewriteSelfSetAttrs(const std::string& selfName,
                    const ImmutableTreeVector<PythonAstStatement>& body)
    {
    assertOnlySimpleInitStatements(body, selfName);

    std::set<std::string> referencedVariables =
        extractVariablesReferencedInFunctionBody(
            body
            );

    SetOfStringPairs selfSetItemMap;

    RewriteSelfSetAttrsTransformer transformer(
        selfSetItemMap,
        referencedVariables,
        selfName
        );

    ImmutableTreeVector<PythonAstStatement> transformedBody =
        transform(body, transformer);

    return std::make_pair(transformedBody, selfSetItemMap);
    }

void checkFunctionArgs(
        const PythonAstArguments& args,
        const SimpleParseRange& extent
        )
    {
    if (args.vararg().isValue())
        throw PythonToForaConversionError(
            "don't know how to handle *args yet",
            extent
            );
    if (args.kwarg().isValue())
        throw PythonToForaConversionError(
            "don't know how to handle **kwargs yet",
            extent
            );
    }

// we could probably move a more general 'slice' member function
// on PythonAstArguments, but this serves our purposes for now
PythonAstArguments dropFirstNormalArg(const PythonAstArguments& args)
    {
    if (args.defaults().size() < args.args().size())
        {
        return PythonAstArguments(
            args.args().slice(1),
            args.vararg(),
            args.kwarg(),
            args.defaults()
            );
        }

    lassert(args.defaults().size() == args.args().size());

    return PythonAstArguments(
        args.args().slice(1),
        args.vararg(),
        args.kwarg(),
        args.defaults().slice(1)
        );
    }

class MembersTupleTranformer {
private:
    const std::unordered_map<std::string, std::string>& mNewNamesToOriginal;
    const std::string& mSelfName;
    const std::string& mMembersTupleName;
public:
    MembersTupleTranformer(
            const std::unordered_map<std::string, std::string>& newNamesToOriginal,
            const std::string& selfName,
            const std::string& membersTupleName
            ):
        mNewNamesToOriginal(newNamesToOriginal),
        mSelfName(selfName),
        mMembersTupleName(membersTupleName)
        {
        }

    template<class T>
    Nullable<T> processDown(const T& t, bool& b) const
        {
        return null();
        }

    template<class T>
    Nullable<T> processUp(const T& t) const
        {
        return null();
        }

    Nullable<Expression> processUp(const Expression& expr) const
        {
        @match Expression(expr)
            -| Assign (toAssign, value) ->> {
                Nullable<Expression> memberTupleAssignment = processAssign(toAssign, value);
                return memberTupleAssignment.isValue() ?
                    null() << Expression::Sequence(expr, *memberTupleAssignment) :
                    null();
                }
            -| Call (agent, arguments) ->> {
                if (!isFirstArgOfUnnamedArgsTupleSelf(arguments) or
                    !isInitMember(agent))
                    return null();

                return null() << Expression::Assign(
                        PatternWithName::Anything(null() << Symbol(mMembersTupleName)),
                        Expression::CreateTuple(emptyTreeVec() +
                            ApplyArgument::TupleCall(
                                Expression::Member(
                                    Expression::Call(
                                        agent.getMember().agent(),
                                        dropFirstArgOfUnnamedArgsTuple(arguments)
                                        ),
                                    Symbol(MEMBERS_TUPLE_NAME), 1
                                    )
                                ) +
                            ApplyArgument::TupleCall(
                                Expression::Variable(Symbol(mMembersTupleName))
                                )
                            )
                        );
                }

            -| _ ->> { return null(); }
        }
private:
    Nullable<Expression> processAssign(const PatternWithName& toAssign,
                                       const Expression& value) const
        {
        ImmutableTreeSet<Symbol> selfAttributes;

        @match Pattern(toAssign.pattern())
            -| Anything() ->> {
                auto name = toAssign.name();
                lassert(name.isValue());
                if (mNewNamesToOriginal.find(name->toString()) != mNewNamesToOriginal.end())
                    selfAttributes = selfAttributes + *name;
                }
            -| ExpressionMatch(expr, pattern) ->> {
                if (isTupleAssign(expr))
                    {
                    for (const TuplePatternElement& el: pattern.matchers())
                        {
                        lassert_dump(el.isNormal(), "varargs not allowed in assignments");
                        auto symbol = el.getNormal().match().name();
                        if (symbol.isValue() &&
                                mNewNamesToOriginal.find(symbol->toString()) != mNewNamesToOriginal.end())
                            selfAttributes = selfAttributes + *symbol;
                        }
                    }
                }
            -| _ ->> {
                LOG_ERROR << "Unexpected Pattern type: " << toAssign.pattern();
                }

        if (selfAttributes.size() == 0)
            return null();

        ImmutableTreeVector<ApplyArgument> assignValues = mapITV(
                selfAttributes,
                [&](Symbol newName) {
                    return ApplyArgument::Normal(
                        null() << Symbol(mNewNamesToOriginal.at(newName.toString())),
                        Expression::Variable(newName)
                        );
                });
        assignValues = assignValues + ApplyArgument::TupleCall(
                Expression::Variable(Symbol(mMembersTupleName))
                );
        return null() << Expression::Assign(
                            PatternWithName::Anything(null() << Symbol(mMembersTupleName)),
                            Expression::CreateTuple(assignValues)
                            );
        }

    bool isFirstArgSelf(const ImmutableTreeVector<ApplyArgument>& arguments) const
        {
        if (arguments.size() == 0)
            return false;

        @match ApplyArgument(arguments[0])
            -| Normal (name, expr) ->> {
                return expr.isVariable() &&
                    expr.getVariable().variable().toString() == mSelfName;
                }
            -| _ ->> { return false; }
        }

    bool isFirstArgOfUnnamedArgsTupleSelf(
            const ImmutableTreeVector<ApplyArgument>& arguments
            ) const
        {
        if (arguments.size() == 0)
            return false;

        @match ApplyArgument(arguments[0])
            -| Normal(name, expr) ->> {
                if (name.isNull() or name->toString() != "@unnamed_args")
                    return false;

                @match Expression(expr)
                    -| CreateTuple(args) ->> {
                        return isFirstArgSelf(args);
                        }
                    -| _ ->> { return false; }
                    ;
                }
            -| _ ->> { return false; }
        ;
        }

    ImmutableTreeVector<ApplyArgument> dropFirstArgOfUnnamedArgsTuple(
            const ImmutableTreeVector<ApplyArgument>& arguments
            ) const
        {
        // assumed to be called on a tuple of the form
        //(@unnamed_args: (arg0, *args1), *args2)

        ImmutableTreeVector<ApplyArgument> tr;

        lassert(arguments.size() > 0);

        @match ApplyArgument(arguments[0])
            -| Normal(name, expr) ->> {
                lassert(name.isValue() and name->toString() == "@unnamed_args");

                @match Expression(expr)
                    -| CreateTuple(args) ->> {
                        return emptyTreeVec() +
                            ApplyArgument::Normal(
                                name,
                                Expression::CreateTuple(
                                    args.slice(1)
                                    )
                                ) +
                            arguments.slice(1)
                            ;
                        }
                    -| _ ->> { lassert(false); }
                }
            -| _ ->> { lassert(false); }
            ;
        }

    bool isInitMember(const Expression& agent) const
        {
        @match Expression(agent)
            -| Member (agent, member, depth) ->> {
                return member.toString() == "__init__";
                }
            -| _ ->> { return false; }
        }

    bool isTupleAssign(const Expression& expr) const
        {
        @match Expression(expr)
            -| Constant(val) ->> {
                return val.type().isTuple() &&
                    *val.tupleGetSize() == 2 &&
                    *val.tupleGetItem(0) == CSTValue::Tag(Symbol("TupleAssign"));
                }
            -| _ ->> { return false; }
        }
};


Expression populateMembersTuple(const Expression& expr,
                                const SetOfStringPairs& selfSetItemMap,
                                const std::string& selfName,
                                const std::string& membersTupleName)
    {
    std::unordered_map<std::string, std::string> newNamesToOriginal;
    for (const auto& p: selfSetItemMap)
          newNamesToOriginal[p.second] = p.first;

    MembersTupleTranformer transformer(
            newNamesToOriginal,
            selfName,
            membersTupleName);
    return transform(expr, transformer);
    }


    Expression makeMemberChain(ImmutableTreeVector<std::string> names)
        {
        if (names.size() == 1)
            return Expression::Variable(Symbol(names[0]));

        return Expression::Member(
                makeMemberChain(names.slice(0, names.size() - 1)),
                Symbol(names[names.size() - 1]),
                1
                );

        }

} // anonymous namespace

namespace Fora {

ImplValContainer getModuleMember(ImplValContainer module, std::string memberName)
    {
    FunctionStage1::Simulation simulation(100);

    FunctionStage1::ExpressionEvaluationResult result =
        simulation.evaluateApply(
            emptyTreeVec() +
                module +
                ImplValContainerUtilities::createSymbol(Symbol("Member")) +
                ImplValContainerUtilities::createSymbol(Symbol(memberName))
            );

    lassert(result.isResult());

    return result.getResult().val();
    }



PythonAstConverter::PythonAstConverter(
            PolymorphicSharedPtr<PythonConstantConverter> constantConverter,
            PolymorphicSharedPtr<PythonListConverter> listConverter,
            PolymorphicSharedPtr<PythonTupleConverter> tupleConverter,
            PolymorphicSharedPtr<PythonDictConverter> dictConverter,
            ImplValContainer pyforaBuiltins,
            const ImmutableTreeMap<
                Symbol,
                pair<ImplValContainer, Nullable<Symbol>>
                >& builtinMemberMapping
            )
        : mConstantConverter(constantConverter),
          mPythonListConverter(listConverter),
          mPythonTupleConverter(tupleConverter),
          mPythonDictConverter(dictConverter),
          mPyforaBuiltins(pyforaBuiltins),
          mBuiltinMemberMapping(builtinMemberMapping)
    {
    mPyBoundMethod = getModuleMember(pyforaBuiltins, "PyBoundMethod");

    mPyObjectBaseMixin = getModuleMember(pyforaBuiltins, "PyObjectBase");
    lassert_dump(mPyObjectBaseMixin.type().isClass() || mPyObjectBaseMixin.type().isNothing(),
                 "pyObjectBaseMixin must be 'noting' or an object");

    mPyGeneratorFactory = getModuleMember(pyforaBuiltins, "Generator");

    mPySliceFactory = getModuleMember(pyforaBuiltins, "Slice");

    mPyListType = getModuleMember(pyforaBuiltins, "ListType");

    mTypeError = getModuleMember(pyforaBuiltins, "TypeError");

    mPyString = getModuleMember(pyforaBuiltins, "PyString");

    mPyDictType = getModuleMember(pyforaBuiltins, "DictType");

    mAssertionError = getModuleMember(pyforaBuiltins, "AssertionError");
    }

Expression PythonAstConverter::invalidPyforaCodeExpression(SimpleParseRange extent) const
    {
    return CPPML::replaceCommonData(
            Expression::Constant(CSTValue(mPyObjectBaseMixin))
                .member(Symbol("__pyfora_unconvertible_code__"))(),
            ExpressionLocationMetadata::WithSimpleParseRange(extent)
            );
    }

PolymorphicSharedPtr<PythonConstantConverter> PythonAstConverter::constantConverter() const
    {
    return mConstantConverter;
    }

/*
We've got an ITV<ClassDefinitionTerm> here because certain python class body statements produce
more than one Fora ClassDefinitionTerm, for example __init__ gives a Constructor and (possibly)
DataMembers.
*/
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyStatementToForaClassDefinitionTerms(
        const PythonAstStatement& statement,
        const std::string& className
        ) const
    {
    @match PythonAstStatement(statement)
        -| FunctionDef(_, _, _, _) ->> {
            return convertPythonClassBodyFunctionDefToForaClassDefinitionTerms(
                statement.getFunctionDef(),
                statement.extent(),
                className
                );
            }
        -| Pass() ->> {
            return emptyTreeVec();
            }
        -| Expr(Str(s)) ->> {
            ///This swallows doc strings
            return emptyTreeVec();
            }
        -| Print(files, values) ->> {
            return emptyTreeVec();
            }
        -| _ ->> {
            std::ostringstream oss;
            oss << PYFORA_CONVERSION_ERROR_MESSAGE;
            LOG_INFO << "Conversion error. Statement isn't FunctionDef, Pass, or Expr(Str): " << statement;
            throw PythonToForaConversionError(
                oss.str(),
                statement.extent()
                );
            }
    }

Expression PythonAstConverter::initializeUnboundVariablesForFunction(
        const TuplePattern& pattern,
        const Expression& inputFunctionBody
        ) const
    {
    Expression functionBody = inputFunctionBody;

    //look at all the variables we assign to at the root scope. If they are not bound
    //then they are 'free', but also assigned. We don't allow globals, so they'll all need
    //null let bindings
    ImmutableTreeSet<Symbol> bound = pattern.boundVariables();
    ImmutableTreeSet<Symbol> assigned = functionBody.assignedVariables();
    ImmutableTreeSet<Symbol> needingBindings = assigned - bound;

    for (const auto& s: needingBindings)
        functionBody = Expression::Let(
            s,
            Expression::Constant(CSTValue(Symbol("PyforaUninitializedVariable"))),
            rebindFreeAs(functionBody, emptyTreeMap() + s + checkVariableValidityExpression(s))
            );

    return functionBody;
    }

// should only be called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm
// which does some preliminary verification
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonInitDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const std::string& className
        ) const
    {
    PythonAstArguments nonSelfArgs = dropFirstNormalArg(functionDef.args());

    TuplePatternElement selfArg = TuplePatternElement::Normal(
        null(),
        convertPythonAstExpressionToPattern(functionDef.args().args()[0]),
        null()
        );

    std::string selfName;
        {
        lassert(selfArg.isNormal());

        auto nullableName = selfArg.getNormal().match().name();

        lassert(nullableName.isValue());
        selfName = nullableName->toString();
        }

    ImmutableTreeVector<TuplePatternElement> foraArgs =
        computeForaArgs(nonSelfArgs);

    std::pair<ImmutableTreeVector<PythonAstStatement>, SetOfStringPairs>
        transformedBodyAndSelfSetItemMap = rewriteSelfSetAttrs(
            selfName,
            functionDef.body()
            );

    assertNoStraySelfArgsInTransformedInitBody(
        transformedBodyAndSelfSetItemMap.first,
        selfName
        );

    TuplePattern pattern = TuplePattern(foraArgs);
    Expression functionBody =
        convertPythonAstStatementsToExpression(
            transformedBodyAndSelfSetItemMap.first
            );

    functionBody = populateMembersTuple(
            functionBody,
            transformedBodyAndSelfSetItemMap.second,
            selfName,
            "@members");

    Expression createInstanceCall = makeCreateInstanceCall("@members", className);

    functionBody = Expression::Let(
            emptyTreeVec() + std::make_pair(
                PatternWithName::Anything(null() << Symbol("@members")),
                Expression::CreateTuple(ImmutableTreeVector<ApplyArgument>())
                ),
            Expression::Sequence(functionBody, createInstanceCall)
            );

    functionBody = initializeUnboundVariablesForFunction(pattern, functionBody);

    ImmutableTreeVector<ClassDefinitionTerm> tr = emptyTreeVec() +
        ClassDefinitionTerm::DataMember(Symbol(MEMBERS_TUPLE_NAME)) +
        ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                MEMBERS_TUPLE_NAME,
                Expression::Variable(Symbol(MEMBERS_TUPLE_NAME))
                )
            );

    for (const auto& p: transformedBodyAndSelfSetItemMap.second)
        {
        tr = tr + ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                p.first,
                Expression::Member(
                    Expression::Variable(Symbol(MEMBERS_TUPLE_NAME)),
                    Symbol(p.first),
                    1)
                )
            );
        }

    // For generated operator news, we need two function signatures:
    // one of the form (@unnamed_args:, @named_args:), and the "old" form.
    // The reason we need the old form is that in other parts
    // of our framework we instantiate by using FunctionStage1Simulator,
    // and that's easier with the old form.

    return tr + ClassDefinitionTerm::Constructor(
        Function::Term(
            pattern,
            functionBody,
            adaptedArgumentsClauseForInit(
                className,
                nonSelfArgs,
                foraArgs,
                SimpleParseRange()
                )
            )
        );
    }


Function PythonAstConverter::adaptedArgumentsClauseForInit(
        const std::string& className,
        const PythonAstArguments& nonSelfArgs,
        const ImmutableTreeVector<TuplePatternElement>& foraArgs,
        const SimpleParseRange& extent
        ) const
    {
    // add a function clause which matches the "new" calling convention,
    // (@unnamed_args:, @named_args:) into the old form (this just forwards the args)

    auto unpackedArguments =
        unpackArguments(
            nonSelfArgs,
            extent,
            className
            );

    // I'm concerned about the consistency of foraArgs and unpackedArguments
    // but that will generate an invalid call if they don't match up

    return Function::Term(
        TuplePattern(
            emptyTreeVec() +
            TuplePatternElement::Normal(
                null() << Symbol("@unnamed_args"),
                PatternWithName::Anything(
                    null() << Symbol("@unnamed_args")
                    ),
                null()
                ) +
            TuplePatternElement::Normal(
                null() << Symbol("@named_args"),
                PatternWithName::Anything(
                    null() << Symbol("@named_args")
                    ),
                null()
                )
            ),
        Expression::Let(
            unpackedArguments,
            Expression::Call(
                Expression::Variable(className),
                initApplyArgsFromForaArgs(foraArgs, extent)
                )
            ),
        Function::Empty()
        );
    }


ImmutableTreeVector<ApplyArgument> PythonAstConverter::initApplyArgsFromForaArgs(
        const ImmutableTreeVector<TuplePatternElement>& foraArgs,
        const SimpleParseRange& extent
        ) const
    {
    ImmutableTreeVector<ApplyArgument> tr;

    for (const auto& foraArg: foraArgs)
        {
        @match TuplePatternElement(foraArg)
            -|  Normal(fieldName, patternWithName, defaultValue) ->> {
                if (patternWithName.condition().isValue() or
                    !patternWithName.pattern().isAnything() or
                    patternWithName.name().isNull())
                    throw PythonToForaConversionError(
                        std::string("don't know how to handle this"),
                        extent
                        );

                tr = tr + Expression::Variable(*patternWithName.name())
                    .normalApplyArg();
                }
            -|  VarArgs(varName) ->> {
                throw PythonToForaConversionError(
                    std::string("don't know how to handle varargs here"),
                    extent
                    );
                }
            ;
        }

    return tr;
    }


ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyFunctionDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent,
        const std::string& className
        ) const
    {
    PythonAstArguments args = functionDef.args();

    checkFunctionArgs(args, extent);

    const std::string& functionName = functionDef.name();

    ImmutableTreeVector<PythonAstExpr> decoratorList = functionDef.decorator_list();

    //check if it's @staticmethod or @property
    ImmutableTreeVector<PythonAstStatement> body = functionDef.body();
    if (decoratorList.size() > 0) {
        if (decoratorList.size() == 1
            and decoratorList[0].isName())
            {
            const std::string& decoratorName = decoratorList[0].getName().id();

            if (decoratorName == "staticmethod") {
                return
                    convertPythonClassBodyStaticMethodFunctionDefToForaClassDefinitionTerms(
                        functionDef,
                        extent
                        );
                }
            else if (decoratorName == "property") {
                return emptyTreeVec() +
                    convertPythonClassBodyPropertyToForaClassDefinitionTerm(
                        functionDef,
                        extent
                        );
                }
            }

        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for functions, "
            "besides \"staticmethod\" and \"property\", right now",
            extent
            );
        }

    if (args.args().size() == 0)
        {
        return emptyTreeVec() +
            createInvalidNumberOfArgumentsClassDefinitionTerm(
                functionDef.name()
                );
        }

    if (functionName == "__init__")
        {
        // should assert that there are no decorators
        if (decoratorList.size() > 0)
            throw PythonToForaConversionError(
                "don't know how to convert `__init__` methods with decorators right now",
                extent
                );

        return convertPythonInitDefToForaClassDefinitionTerms(functionDef, className);
        }

    Function function =
        convertFunctionDefToForaFunction(
            functionDef,
            extent
            );

    //expose the function member as a ...(`Member, `f) { fun() {...} }
    //so that we don't capture 'f' in the class binding
    auto res = emptyTreeVec() + ClassDefinitionTerm::ObjectTerm(
        noncapturingObjectMember(
            functionName,
            Expression::Call(
                Expression::Constant(mPyBoundMethod),
                emptyTreeVec() +
                    Expression::Variable(Symbol("@self")).normalApplyArg() +
                    Expression::CreateFunction(
                        functionName,
                        function,
                        CSTValue()
                        ).normalApplyArg() +
                    Expression::Constant(CSTValue(Symbol(functionName))).normalApplyArg()
                )
            )
        );

    return res;
    }

namespace {
    Expression constantExpressionForImplVal(const ImplValContainer& val)
        {
        return Expression::Constant(CSTValue(val));
        }
    }

Expression PythonAstConverter::convertPythonAstLambdaToFora(
                    const PythonAstArguments& arguments,
                    const PythonAstExpr& body,
                    const SimpleParseRange& extent
                    ) const
    {
    return convertPythonAstFunctionDefToFora(
        PythonAstStatement_FunctionDefType(
            "<lambda>",
            arguments,
            emptyTreeVec() + PythonAstStatement::Return(null() << body),
            emptyTreeVec()
            ),
        extent
        );
    }

Expression PythonAstConverter::convertNullableExpressionToExpression(
        const Nullable<PythonAstExpr>& expr
        ) const
    {
    if (expr.isNull())
        return Expression::Constant(mConstantConverter->noneValue());

    return convertPythonAstExpressionToFora(*expr);
    }

Expression PythonAstConverter::convertPythonAstSliceToExpression(
        const PythonAstSlice& slice,
        const SimpleParseRange& extent
        ) const
    {
    @match PythonAstSlice(slice)
        -| Ellipsis() ->> {
            // not dealing with this just yet. we'll get to it
            LOG_INFO << "Conversion error. Slice is Ellipsis: " << slice;
            return invalidPyforaCodeExpression(extent);
            }
        -| Slice(start, stop, step) ->> {
            return
                Expression::Apply(
                    Expression::Constant(
                        CSTValue(mPySliceFactory)
                        ),
                    emptyTreeVec() +
                        ApplyArgument::Normal(
                            Expression::Constant(
                                CSTValue(Symbol("Call"))
                                )
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(start)
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(stop)
                            ) +
                        ApplyArgument::Normal(
                            convertNullableExpressionToExpression(step)
                            )
                    );
            }
        -| ExtSlice(slices) ->> {
            ImmutableTreeVector<ApplyArgument> tupleArgs = mapITV(
                slices,
                [this, extent](PythonAstSlice slice) {
                    return ApplyArgument::Normal(
                        convertPythonAstSliceToExpression(slice, extent)
                        );
                    }
                );

            return mPythonTupleConverter->createTupleExpression(
                Expression::CreateTuple(tupleArgs)
                );
            }
        -| Index(value) ->> {
            return convertPythonAstExpressionToFora(value);
            }
        ;
    }

Expression PythonAstConverter::wrapExpressionInPyContinueCheck(Expression e) const
    {
    return Expression::Try(
        e,
        Function::Term(
            TuplePattern(
                emptyTreeVec() +
                    TuplePatternElement::Normal(
                        PatternWithName::Constant(CSTValue(Symbol("PyContinue")))
                        )
                ),
            Expression(),
            Function::Empty()
            ),
        null(),
        false
        );
    }

Expression
PythonAstConverter::convertPythonAstExpressionToFora_inner(
        const PythonAstExpr& expr
        ) const
    {
    @match PythonAstExpr(expr)
        -| Str(stdString) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertString(stdString)
                );
            }
        -| Num(Int(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertInt(value)
                );
            }
        -| Num(Long(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertLong(value)
                );
            }
        -| Num(Boolean(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertBoolean(value)
                );
            }
        -| Num(None()) ->> {
             return constantExpressionForImplVal(
                constantConverter()->noneValue()
                );
             }
        -| Num(Float(value)) ->> {
            return constantExpressionForImplVal(
                constantConverter()->convertFloat(value)
                );
            }
        -| BoolOp(And(), exprs) ->> {
            lassert(exprs.size() > 0)

            Expression res = convertPythonAstExpressionToFora(exprs.back());

            for (long k = exprs.size() - 2; k >= 0; k--)
                {
                Symbol conditional("@conditional");

                res = Expression::Let(
                    conditional,
                    convertPythonAstExpressionToFora(exprs[k]),
                    Expression::Branch(
                        convertExpressionToForaBoolean(
                            Expression::Variable(conditional)
                            ),
                        res,
                        null() << Expression::Variable(conditional)
                        )
                    );
                }

            return res;
            }
        -| BoolOp(Or(), exprs) ->> {
            lassert(exprs.size() > 0)

            Expression res = convertPythonAstExpressionToFora(exprs.back());

            for (long k = exprs.size() - 2; k >= 0; k--)
                {
                Symbol conditional("@conditional");

                res = Expression::Let(
                    conditional,
                    convertPythonAstExpressionToFora(exprs[k]),
                    Expression::Branch(
                        convertExpressionToForaBoolean(
                            Expression::Variable(conditional)
                            ),
                        Expression::Variable(conditional),
                        null() << res
                        )
                    );
                }

            return res;
            }
        -| Attribute(value, attribute, ctx) ->> {
            Expression agent = convertPythonAstExpressionToFora(value);

            return agent.member(Symbol(attribute));
            }
        -| Subscript(value, slice, ctx) ->> {
            Expression valueGetItemMemberFunction =
                Expression::Member(
                    convertPythonAstExpressionToFora(value),
                    Symbol("__getitem__"),
                    1
                    );

            auto sliceArg =
                ApplyArgument::Normal(
                    convertPythonAstSliceToExpression(slice, expr.extent())
                    );

            return Expression::Call(
                valueGetItemMemberFunction,
                emptyTreeVec() + sliceArg
                );
            }
        -| GeneratorExp(expr, generators) ->> {
            lassert(generators.size());

            /************************************
            generator-expressions get transformed as follows:

                (expr for pat in generator if filterExpr)

            becomes

                generator.__pyfora_generator__().filter(lambda pat: filterExpr).map(lambda pat: expr)

            with nested iterators, we have

                (expr1 for pat1 in generator if filtExpr for pat2 in sub_generator if filtExpr2)

            becoming

                generator
                    .__pyfora_generator__()
                    .filter(lambda pat1: filtExpr)
                    .nest(lambda pat1:
                        sub_generator
                            .__pyfora_generator__()
                            .filter(lambda pat2: filtExpr2)
                            .map(lambda pat2: expr)
                        )

            ***********************************/

            Nullable<Expression> accumulator;

            for (long genIx = generators.size() - 1; genIx >= 0; genIx--)
                {
                Expression generator =
                    convertPythonAstExpressionToFora(generators[genIx].iter())
                        .member(Symbol("__pyfora_generator__"))();

                for (const auto& c: generators[genIx].conditions())
                    generator = generator.member(Symbol("filter"))(
                        convertPythonAstExpressionToFora(
                            PythonAstExpr::Lambda(
                                PythonAstArguments(
                                    emptyTreeVec() + generators[genIx].target(),
                                    null(),
                                    null(),
                                    emptyTreeVec()
                                    ),
                                c
                                )
                            )
                        );

                //the first time in the loop, we are calculating the
                if (!accumulator)
                    accumulator = generator.member(Symbol("map"))(
                        convertPythonAstExpressionToFora(
                            PythonAstExpr::Lambda(
                                PythonAstArguments(
                                    emptyTreeVec() + generators[genIx].target(),
                                    null(),
                                    null(),
                                    emptyTreeVec()
                                    ),
                                expr
                                )
                            )
                        );
                else
                    accumulator = generator.member(Symbol("nest"))(
                        createObjectImplementingCallOperatorForFunction(
                            Function::Term(
                                TuplePattern(
                                    emptyTreeVec() +
                                        TuplePatternElement::Normal(
                                            convertPythonAstExpressionToPattern(
                                                generators[genIx].target()
                                                )
                                            )
                                    ),
                                *accumulator,
                                Function::Empty()
                                ),
                            "<lambda>",
                            null()
                            )
                        );
                }

            return *accumulator;
            }
        -| ListComp(elt, generators) ->> {
            ImmutableTreeSet<Symbol> assigned;
            for (const auto& gen: generators)
                assigned = assigned + convertPythonAstExpressionToPattern(
                    gen.target()
                    ).boundVariables();

            auto res =
                Expression::Constant(mPyListType)(
                    convertPythonAstExpressionToFora(
                        PythonAstExpr::GeneratorExp(elt, generators)
                        )
                    );

            for (const auto& var: assigned)
                res = Expression::Sequence(
                    Expression::Assign(
                        PatternWithName::Anything(null() << var),
                        Expression::Constant(CSTValue(Symbol("PyforaInvalidVariable")))
                        ),
                    res
                    );

            return res;
            }
        -| List(elts) ->> {
            return mPythonListConverter->convertPyList(
                expr.getList(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this,
                    _1
                    )
                );
            }
        -| Dict(elts) ->> {
            return mPythonDictConverter->convertPyDict(
                expr.getDict(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this,
                    _1
                    )
                );
            }
        -| DictComp(key, value, generators) ->> {
            PythonAstExpr pyUpdateSequence =
                PythonAstExpr::ListComp(
                    PythonAstExpr::Tuple(
                        emptyTreeVec() + key + value,
                        PythonAstExprContext::Load()
                        ),
                    generators
                    );

            Expression foraUpdateSequence =
                convertPythonAstExpressionToFora(
                    pyUpdateSequence
                    );

            return Expression::Call(
                Expression::Constant(
                    mPyDictType
                    ),
                emptyTreeVec() +
                foraUpdateSequence.normalApplyArg()
                );
            }
        -| Tuple(elts) ->> {
            return mPythonTupleConverter->convertPyTuple(
                expr.getTuple(),
                boost::bind(
                    &PythonAstConverter::convertPythonAstExpressionToFora,
                    this,
                    _1
                    )
                );
            }
        -| UnaryOp(op, rhs) ->> {
            Symbol opAsSymbol;

            @match PythonAstUnaryOp(op)
                -| Invert() ->> { opAsSymbol = Symbol("~"); }
                -| Not() ->> { opAsSymbol = Symbol("!"); }
                -| UAdd() ->> { opAsSymbol = Symbol("+"); }
                -| USub() ->> { opAsSymbol = Symbol("-"); }
                ;

            return Expression::LeftOperator(
                opAsSymbol,
                convertPythonAstExpressionToFora(rhs)
                );
            }
        -| BinOp(lhs, Add(), List(Leaf(elt, Empty()))) ->> {
            Expression convertedLhs = convertPythonAstExpressionToFora(lhs);
            Expression convertedElt = convertPythonAstExpressionToFora(elt);

            return mPythonListConverter->concatSingleEltVectorExpr(
                convertedLhs, convertedElt
                );
            }
        -| BinOp(lhs, op, rhs) ->> {
            Symbol opAsSymbol;

            @match PythonAstBinaryOp(op)
                -| Add() ->> { opAsSymbol = Symbol("+"); }
                -| Sub() ->> { opAsSymbol = Symbol("-"); }
                -| Mult() ->> { opAsSymbol = Symbol("*"); }
                -| Div() ->> { opAsSymbol = Symbol("/"); }
                -| Mod() ->> { opAsSymbol = Symbol("%"); }
                -| Pow() ->> { opAsSymbol = Symbol("**"); }
                -| LShift() ->> { opAsSymbol = Symbol("<<"); }
                -| RShift() ->> { opAsSymbol = Symbol(">>"); }
                -| BitOr() ->> { opAsSymbol = Symbol("|"); }
                -| BitXor() ->> { opAsSymbol = Symbol("^"); }
                -| BitAnd() ->> { opAsSymbol = Symbol("&"); }
                -| FloorDiv() ->> { opAsSymbol = Symbol("//"); }
                ;

            return Expression::BinaryOperator(
                convertPythonAstExpressionToFora(lhs),
                opAsSymbol,
                convertPythonAstExpressionToFora(rhs)
                );
            }
        -| Lambda(arguments, body) ->> {
            return convertPythonAstLambdaToFora(arguments, body, expr.extent());
            }
        -| IfExp(cond, ifTrue, ifFalse) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaBoolean(cond),
                convertPythonAstExpressionToFora(ifTrue),
                null() << convertPythonAstExpressionToFora(ifFalse)
                );
            }
        -| Repr(expr) ->> {
            return Expression::Call(
                Expression::Constant(CSTValue(Symbol("ParsableRepresentation"))),
                emptyTreeVec() +
                    ApplyArgument::Normal(
                        convertPythonAstExpressionToFora(expr)
                        )
                );
            }
        -| Compare(expr, comparisons, comparisonExprs) ->> {
            if (comparisons.size() != comparisonExprs.size())
                throw PythonToForaConversionError(
                    "valid python should have an equal number of comparison operators and expressions",
                    expr.extent()
                    );

            if (comparisons.size() != 1)
                throw PythonToForaConversionError(
                    "don't know how to convert chained comparisons yet.",
                    expr.extent()
                    );

            Expression curExpr = convertPythonAstExpressionToFora(expr);
            Expression result;

            for (long k = 0; k < comparisons.size(); k++)
                {
                Expression curRhs = convertPythonAstExpressionToFora(comparisonExprs[k]);

                Expression toAdd;

                @match PythonAstComparisonOp(comparisons[k])
                    -| Eq() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("=="), curRhs); }
                    -| NotEq() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("!="), curRhs); }
                    -| Lt() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("<"), curRhs); }
                    -| LtE() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol("<="), curRhs); }
                    -| Gt() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol(">"), curRhs); }
                    -| GtE() ->> { toAdd = Expression::BinaryOperator(curExpr, Symbol(">="), curRhs); }
                    -| Is() ->> {
                        toAdd = Expression::Branch(
                            Expression::Is(curExpr, curRhs),
                            Expression::Constant(mConstantConverter->convertBoolean(true)),
                            null() << Expression::Constant(mConstantConverter->convertBoolean(false))
                            );
                        }
                    -| IsNot() ->> {
                        toAdd = Expression::Branch(
                            Expression::IsNot(curExpr, curRhs),
                            Expression::Constant(mConstantConverter->convertBoolean(true)),
                            null() << Expression::Constant(mConstantConverter->convertBoolean(false))
                            );
                        }
                    -| In() ->> { toAdd = Expression::In(curExpr, curRhs); }
                    -| NotIn() ->> {
                        toAdd = Expression::Branch(
                            convertExpressionToForaBoolean(
                                Expression::In(curExpr, curRhs)
                                ),
                            Expression::Constant(
                                mConstantConverter->convertBoolean(false)
                                ),
                            null() << Expression::Constant(
                                mConstantConverter->convertBoolean(true)
                                )
                            );
                        }
                    ;

                if (k == 0)
                    result = toAdd;
                else
                    result = Expression::And(result, toAdd);
                }

            return result;
            }
        -| Yield(e) ->> {
            return
                Expression::Continuation(
                    Function::Term(
                        TuplePattern(emptyTreeVec() +
                            TuplePatternElement::Normal(
                                PatternWithName::Anything(null() << Symbol("@continuation"))
                                )
                            ),
                        Expression::Return(
                            Expression::CreateTuple(
                                emptyTreeVec() +
                                    ApplyArgument::Normal(
                                        e ? convertPythonAstExpressionToFora(*e) : Expression()
                                        ) +
                                    ApplyArgument::Normal(Expression::Variable(Symbol("@continuation")))
                                )
                            ),
                    Function::Empty()
                    )
                );
            }
        -| Call(func, args, kwds, starArgs, kwargs) ->> {
            if (func.isName() and func.getName().id() == __inline_fora_string)
                return convertInlineFora(expr.getCall(), expr.extent());

            if (starArgs.isValue())
                throw PythonToForaConversionError(
                    "don't know how to convert starArgs just yet.",
                    expr.extent()
                    );

            if (kwargs.isValue())
                throw PythonToForaConversionError(
                    "don't know how to convert kwargs just yet.",
                    expr.extent()
                    );

            return Expression::Call(
                convertPythonAstExpressionToFora(func),
                adaptPyArgsToForaCallingConvention(
                    args,
                    kwds
                    )
                );

            }
        -| Name(identifier, Load()) ->> {
            //when loading variables, we need to check whether they are specific symbols
            //that we use to denote states like 'uninitialized' or 'invalid'. If so, we defer
            //to a member of the PyObjectBase to figure out what to do
            assertValidNameIdentifier(identifier, expr.extent());

            return Expression::Variable(Symbol(identifier));
            }
        -| _ ->> {
            }

    LOG_INFO << "Conversion error. Unexpected expression: " << expr;
    return invalidPyforaCodeExpression(expr.extent());
    }

ImmutableTreeVector<ApplyArgument>
PythonAstConverter::adaptPyArgsToForaCallingConvention(
        const ImmutableTreeVector<PythonAstExpr>& args,
        const ImmutableTreeVector<PythonAstKeyword>& keywords
        ) const
    {
    ImmutableTreeVector<ApplyArgument> tr;

    tr = tr +
        ApplyArgument::Normal(
            null() << Symbol("@unnamed_args"),
            Expression::CreateTuple(
                mapITV(args, [this](const PythonAstExpr& expr) {
                        return ApplyArgument::Normal(
                            convertPythonAstExpressionToFora(expr)
                            );
                        })
                )
            );
    tr = tr +
        ApplyArgument::Normal(
            null() << Symbol("@named_args"),
            Expression::CreateTuple(
                mapITV(keywords, [this](const PythonAstKeyword& keyword) {
                        return ApplyArgument::Normal(
                            null() << Symbol(keyword.arg()),
                            convertPythonAstExpressionToFora(keyword.value())
                            );
                        })
                )
            );

    return tr;
    }

Expression PythonAstConverter::convertInlineFora(
        const PythonAstExpr_CallType& callExpr,
        const SimpleParseRange& extent
        ) const
    {
    if (callExpr.keywords().size() > 0)
        throw PythonToForaConversionError(
            "__inline_fora accepts no keyword args",
            extent
            );

    if (callExpr.starargs().isValue() > 0)
        throw PythonToForaConversionError(
            "__inline_fora accepts no starargs",
            extent
            );

    if (callExpr.kwargs().isValue() > 0)
        throw PythonToForaConversionError(
            "__inline_fora accepts no kwargs",
            extent
            );

    if (callExpr.args().size() != 1)
        throw PythonToForaConversionError(
            "__inline_fora accepts only one argument",
            extent
            );

    const PythonAstExpr& arg = callExpr.args()[0];

    if (!arg.isStr())
        throw PythonToForaConversionError(
            "__inline_fora accepts only string arguments",
            extent
            );

    const std::string& inlineForaCode = arg.getStr().s();
    const SimpleParseNode simpleParseNode = parseStringToSimpleParse(inlineForaCode);

    ParserExpressions p(true, CodeDefinitionPoint(), "");

    Expression inlineForaExpr = p.parseToExpression(simpleParseNode);

    if (!inlineForaExpr.isCreateFunction())
        throw PythonToForaConversionError(
            std::string(
                "only CreateFunction expressions are allowed in inline fora Code. got "
                ) + inlineForaExpr.tagName(),
            extent
            );

    return Expression::Constant(
        bindFreeVariablesInInlineForaExpressionToConstantUsingBuiltins(
            inlineForaExpr.getCreateFunction(),
            inlineForaExpr.freeVariables(),
            extent
            )
        );
    }

CSTValue PythonAstConverter::bindFreeVariablesInInlineForaExpressionToConstantUsingBuiltins(
        const Expression_CreateFunctionType& createFunctionExpression,
        const ImmutableTreeSet<Symbol>& freeVariables,
        const SimpleParseRange& extent
        ) const
    {
    // oh, STL-ops ...
    auto unboundFree = freeVariables - mBuiltinMemberMapping.keySet();

    if (unboundFree.size() > 0)
        throw PythonToForaConversionError(
            std::string("inline fora function had free variables,  ") +
            prettyPrintString(unboundFree) +
            " and this is forbidden",
            extent
            );

    return Fora::Language::bindFunctionWithValues(
        ClassMediator::Function(
            createFunctionExpression.name(),
            createFunctionExpression.predicate(),
            LexicalBindingMap(),
            CSTValue()
            ),
        mBuiltinMemberMapping,
        createFunctionExpression.objectMetadata()
        );
    }

Expression
PythonAstConverter::convertExpressionToForaBoolean(const Expression& expr) const
    {
    //we need to convert this to a bool, which we do by calling PyBool (or equivalent as given)
    //and then calling 'Bool' on that
    return Expression::Apply(expr,
            emptyTreeVec()
                + Expression::Constant(
                    CSTValue(Symbol("Convert"))
                    ).normalApplyArg()
                + Expression::Constant(
                    CSTValue(JOV::OfType(Type::Integer(1,false)))
                    ).normalApplyArg()
            );
    }

Expression PythonAstConverter::convertPythonAstExpressionToForaBoolean(
        const PythonAstExpr& expr
        ) const
    {
    Expression tr = convertPythonAstExpressionToFora(expr);

    return convertExpressionToForaBoolean(tr);
    }


Expression PythonAstConverter::convertPythonAstExpressionToFora(
        const PythonAstExpr& expr
        ) const
    {
    Expression tr = convertPythonAstExpressionToFora_inner(expr);

    return CPPML::replaceCommonData(
        tr,
        ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
        );
    }

Expression PythonAstConverter::convertPythonAstStatementsToExpression(
        const ImmutableTreeVector<PythonAstStatement>& statements
        ) const
    {
    Expression result;

    for (long ix = 0; ix < statements.size(); ix++)
        {
        @match PythonAstStatement(statements[ix])
            -| Expr(Str(isPyStr)) ->> {
                if (isPyStr == "__without_stacktrace_augmentation")
                    return Expression::Sequence(result,
                        Expression::NoStackTraceAugmentations(
                            convertPythonAstStatementsToExpression(
                                statements.slice(ix+1)
                                )
                            )
                        );
                }
            -| _ ->> {
                }

        result = Expression::Sequence(
            result,
            convertPythonAstStatementToExpression(statements[ix])
            );
        }

    return result;
    }

Function PythonAstConverter::convertPythonAstExceptionHandlers(
        const ImmutableTreeVector<PythonAstExceptionHandler>& handlers
        ) const
    {
    if (handlers.size() == 0)
        return Function::Empty();

    Function tail = convertPythonAstExceptionHandlers(handlers.slice(1));

    PatternWithName pattern = PatternWithName::Anything(null());

    if (handlers[0].name())
        pattern = convertPythonAstExpressionToPattern(*handlers[0].name());

    if (handlers[0].type().isValue())
        {
        Expression e = convertPythonAstExpressionToFora(*handlers[0].type());

        pattern.pattern() =
            Pattern::MatchBoth(
                pattern.pattern(),
                Pattern::ExpressionMatch(
                    e,
                    TuplePattern(emptyTreeVec() + TuplePatternElement::VarArgs(null()))
                    )
                );
        }

    //augment the pattern to insist that it also matches 'PyforaException'
    pattern.pattern() =
        Pattern::MatchBoth(
            pattern.pattern(),
            Pattern::ExpressionMatch(
                Expression::Constant(CSTValue(Symbol("PyforaException"))),
                TuplePattern(emptyTreeVec() + TuplePatternElement::VarArgs(null()))
                )
            );

    TuplePattern pat = TuplePattern(
        emptyTreeVec() + TuplePatternElement::Normal(
            null(),
            pattern,
            null()
            )
        );

    return Function::Term(
        pat,
        convertPythonAstStatementsToExpression(handlers[0].body()),
        tail
        );
    }

Expression PythonAstConverter::convertPythonAstStatementToExpression_inner(
        const PythonAstStatement& statement
        ) const
    {
    @match PythonAstStatement(statement)
        -| FunctionDef(name) ->> {
            assertValidNameIdentifier(name, statement.extent());

            return Expression::Assign(
                PatternWithName::Anything(null() << Symbol(name)),
                convertPythonAstFunctionDefToFora(
                    statement.getFunctionDef(),
                    statement.extent()
                    )
                );
            }
        -| ClassDef(name, bases, body, decoratorList) ->> {
            assertValidNameIdentifier(name, statement.extent());

            return Expression::Assign(
                PatternWithName::Anything(null() << Symbol(name)),
                convertPythonAstClassDefToFora(
                    statement.getClassDef(),
                    statement.extent(),
                    emptyTreeVec()
                    )
                );
            }
        -| Return(Null()) ->> {
            return Expression::Return(Expression::Constant(mConstantConverter->noneValue()));
            }
        -| Return(Value(e)) ->> {
            return Expression::Return(convertPythonAstExpressionToFora(e));
            }
        -| Pass() ->> { return Expression::Constant(mConstantConverter->noneValue()); }
        -| Break() ->> { return Expression::Break(); }
        -| Continue() ->> {
            return Expression::Throw(
                Expression::Constant(CSTValue(Symbol("PyContinue"))), null()
                );
            }
        -| Raise(type, inst, tback) ->> {
            if (type && !inst && !tback)
                {
                return Expression::Throw(
                    convertPythonAstExpressionToFora(*type),
                    Nullable<Expression>()
                    );
                }
            else
                throw PythonToForaConversionError(
                    "We only support 'raise' with a single argument",
                    statement.extent()
                    );
            }
        -| Expr(e) ->> {
            return convertPythonAstExpressionToFora(e);
            }
        -| For(target, iter, body, orelse) ->> {

            Expression leafExpr =
                wrapExpressionInPyContinueCheck(
                    convertPythonAstStatementsToExpression(body)
                    );

            Symbol var = freshVarname(Symbol("@"), mentionedVariables(leafExpr));

            return Expression::Sequence(
                Expression::Foreach(
                    ListComprehensionChain::Term(
                        PatternWithName::Anything(null() << var),
                        null(),
                        convertPythonAstExpressionToFora(iter),
                        ListComprehensionChain::Leaf(
                            Expression::Sequence(
                                Expression::Assign(
                                    convertPythonAstExpressionToPattern(target),
                                    Expression::Variable(var)
                                    ),
                                leafExpr
                                )
                            )
                        )
                    ),
                convertPythonAstStatementsToExpression(orelse)
                );
            }
        -| While(cond, ifTrue, ifFalse) ->> {
            return Expression::Sequence(
                Expression::While(
                    convertPythonAstExpressionToForaBoolean(cond),
                    wrapExpressionInPyContinueCheck(
                        convertPythonAstStatementsToExpression(ifTrue)
                        )
                    ),
                convertPythonAstStatementsToExpression(ifFalse)
                );
            }
        -| If(cond, ifTrue, ifFalse) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaBoolean(cond),
                convertPythonAstStatementsToExpression(ifTrue),
                null() << convertPythonAstStatementsToExpression(ifFalse)
                );
            }
        -| TryExcept(body, handlers, orelse) ->> {
            if (orelse.size() > 0)
                throw PythonToForaConversionError(
                    "don't know how to convert else clauses in try statements",
                    statement.extent()
                    );

            return Expression::Try(
                convertPythonAstStatementsToExpression(body),
                convertPythonAstExceptionHandlers(
                    handlers
                    ),
                null(),
                false
                );
            }
        -| Assign(exprs, expression) ->> {
            if (exprs.size() == 0)
                throw PythonToForaConversionError(
                    "valid python expressions should have a left hand side",
                    statement.extent()
                    );
            if (exprs.size() == 1)
                return Expression::Assign(
                    convertPythonAstExpressionToPattern(exprs[0]),
                    convertPythonAstExpressionToFora(expression)
                    );
            else
                return Expression::Assign(
                    PatternWithName(
                        Pattern::Tuple(
                            TuplePattern(
                                mapITV(exprs, [this](PythonAstExpr ex) {
                                    return TuplePatternElement::Normal(
                                        null(),
                                        convertPythonAstExpressionToPattern(ex),
                                        null()
                                        );
                                    })
                                )
                            ),
                        null(),
                        null(),
                        ExpressionLocationMetadata()
                        ),
                    convertPythonAstExpressionToFora(expression)
                    );
            }
        -| Assert(test, msg) ->> {
            return Expression::Branch(
                convertPythonAstExpressionToForaBoolean(test),
                Expression::Constant(
                    mConstantConverter->noneValue()
                    ),
                null() << Expression::Throw(
                    Expression::Call(
                        Expression::Constant(
                            mAssertionError
                            ),
                        emptyTreeVec() +
                            (msg.isNull() ?
                                Expression::Call(
                                    Expression::Constant(
                                        mPyString
                                        ),
                                    emptyTreeVec() +
                                        Expression::Constant(CSTValue(""))
                                        .normalApplyArg()
                                ).normalApplyArg() :
                            convertPythonAstExpressionToFora(*msg).normalApplyArg())
                        ),
                    null()
                    )
                );
            }
        -| Print(file, values,newline) ->> {
            auto res = Expression::Constant(mConstantConverter->noneValue());
            if (file)
                res = convertPythonAstExpressionToFora(*file);

            ImmutableTreeVector<ApplyArgument> exprs;
            for (const auto& v: values)
                exprs = exprs + convertPythonAstExpressionToFora(v);

            res = Expression::Sequence(
                res,
                Expression::Call(
                    Expression::Constant(CSTValue(mPyObjectBaseMixin))
                        .member(Symbol("__pyfora_print__")),
                    emptyTreeVec() + 
                        ApplyArgument::Normal(Expression::CreateTuple(exprs)) +
                        ApplyArgument::Normal(
                            Expression::Constant(CSTValue(newline != 0 ? true:false))
                            )
                    )
                );
                
            return res;
            }
        -| _ ->> {
            LOG_INFO << "Conversion error. Unexpected statement: " << statement;
            return invalidPyforaCodeExpression(statement.extent());
            }
    }

Expression PythonAstConverter::convertPythonAstStatementToExpression(
        const PythonAstStatement& statement
        ) const
    {
    Expression tr = convertPythonAstStatementToExpression_inner(statement);

    return CPPML::replaceCommonData(
        tr,
        ExpressionLocationMetadata::WithSimpleParseRange(
            statement.extent()
            )
        );
    }

PatternWithName PythonAstConverter::convertPythonAstExpressionToPattern_inner(
        const PythonAstExpr& expr
        ) const
    {
    @match PythonAstExpr(expr)
        -| Name(identifier, _) ->> {
            assertValidNameIdentifier(identifier, expr.extent());
            return PatternWithName::Anything(null() << Symbol(identifier));
            }
        -| Tuple(elts, Store()) ->> {
            return PatternWithName(
                Pattern::ExpressionMatch(
                    Expression::Constant(
                        CSTValue::Tuple(
                            emptyTreeVec() +
                                CSTValue::Tag(Symbol("TupleAssign")) +
                                CSTValue((int64_t)elts.size())
                            )
                        ),
                    TuplePattern(
                        mapITV(elts, [&](PythonAstExpr e) {
                            return TuplePatternElement::Normal(
                                convertPythonAstExpressionToPattern(e)
                                );
                            })
                        )
                    ),
                null(),
                null(),
                ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
                );
            }
        -| _ ->> {
            LOG_INFO << "Conversion error. Expressions is neither Name nor Tuple: " << expr;
            return PatternWithName(
                Pattern::ExpressionMatch(
                    invalidPyforaCodeExpression(expr.extent()),
                    TuplePattern()
                    ),
                null(),
                null(),
                ExpressionLocationMetadata::WithSimpleParseRange(expr.extent())
                );
            }
    }

PatternWithName PythonAstConverter::convertPythonAstExpressionToPattern(
        const PythonAstExpr& expr
        ) const
    {
    PatternWithName tr = convertPythonAstExpressionToPattern_inner(expr);

    return PatternWithName(
        tr.pattern(),
        tr.name(),
        tr.condition(),
        ExpressionLocationMetadata::WithSimpleParseRange(
            expr.extent()
            )
        );
    }


bool isPureMappingDecorator(const PythonAstExpr& expr)
    {
    @match PythonAstExpr(expr)
        -| Call(Name(id, _), _, _, _, _) ->> {
            return id == "pureMapping"
            }
        -| _ ->> { return false; }
    }

namespace {
PythonAstStatement emptyInit()
    {
    return PythonAstStatement::FunctionDef(
        "__init__",
        PythonAstArguments(
            emptyTreeVec() + PythonAstExpr::Name(
                "self",
                PythonAstExprContext::Param()
                ),
            null(),
            null(),
            ImmutableTreeVector<PythonAstExpr>()
            ),
        ImmutableTreeVector<PythonAstStatement>(),
        ImmutableTreeVector<PythonAstExpr>()
        );
    }

bool hasInit(const ImmutableTreeVector<PythonAstStatement>& classBody)
    {
    for(const auto& statement: classBody)
        {
        @match PythonAstStatement(statement)
            -|  FunctionDef(name, _, _, _) ->> {
                if (name == "__init__")
                    return true;
                }
            -|  _ ->> {;}
            ;
        }
    return false;
    }

}

Expression PythonAstConverter::convertPythonAstClassDefToFora(
        const PythonAstStatement_ClassDefType& classDef,
        const SimpleParseRange& extent,
        ImmutableTreeVector<ImmutableTreeVector<std::string>> baseClassChains
        ) const
    {
    const std::string& className = classDef.name();
    ImmutableTreeVector<PythonAstExpr> bases = classDef.bases();
    ImmutableTreeVector<PythonAstStatement> body = classDef.body();
    ImmutableTreeVector<PythonAstExpr> decoratorList = classDef.decorator_list();

    if (decoratorList.size() > 1 ||
            (decoratorList.size() == 1 && !isPureMappingDecorator(decoratorList[0]))) {
        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for classes right now",
            extent
            );
        }

    if (bases.size() != baseClassChains.size()) {
        throw PythonToForaConversionError(
            "don't know how to deal with base classes in nested class definitions right now",
            extent
            );
        }

    ImmutableTreeVector<ClassDefinitionTerm> classDefinitionTerms;

    if (!hasInit(body))
        body = body + emptyInit();

    for (const auto& statement: body) {
        classDefinitionTerms = classDefinitionTerms +
            convertPythonClassBodyStatementToForaClassDefinitionTerms(
                statement,
                className
                );
        }

    classDefinitionTerms = classDefinitionTerms +
        ClassDefinitionTerm::ObjectTerm(
            ObjectDefinitionTerm::Member(
                Symbol("__class__"),
                Expression::Variable(Symbol(className)),
                1
                )
            );

    std::vector<Expression> baseClassExpressions;
    for (const auto& chain: baseClassChains)
        {
        auto expr = makeMemberChain(chain);
        baseClassExpressions.push_back(expr);
        }

    ImmutableTreeVector<ApplyArgument> basesMember;
    for (const auto& base: baseClassExpressions)
        {
        basesMember = basesMember + ApplyArgument::Normal(null(), base);
        }


    classDefinitionTerms = classDefinitionTerms +
        ClassDefinitionTerm::Static(
            ObjectDefinitionTerm::Member(
                Symbol("__bases__"),
                mPythonTupleConverter->createTupleExpression(
                    Expression::CreateTuple(
                        basesMember
                        )
                    ),
                1
                )
            );

    if (baseClassExpressions.size() == 0 && mPyObjectBaseMixin.type().isClass())
        {
        baseClassExpressions.push_back(
            Expression::Variable(Symbol("object"))
            );
        }

    for (const auto& baseExp: baseClassExpressions)
        {
        if (baseExp.isVariable() && baseExp.getVariable().variable().toString() == "object")
            {
            classDefinitionTerms = classDefinitionTerms +
                ClassDefinitionTerm::ObjectTerm(
                    ObjectDefinitionTerm::Mixin(
                        Expression::Constant(
                            CSTValue(mPyObjectBaseMixin)
                            )
                        )
                    );

            //the class object itself is also a PyObject
            classDefinitionTerms = classDefinitionTerms +
                ClassDefinitionTerm::Static(
                    ObjectDefinitionTerm::Mixin(
                        Expression::Constant(
                            CSTValue(mPyObjectBaseMixin)
                            )
                        )
                    );
            }
        else
            {
            classDefinitionTerms = classDefinitionTerms +
                ClassDefinitionTerm::Static(
                    ObjectDefinitionTerm::Mixin(baseExp)
                    );
            }
        }

    ClassDefinitionBody classDefinitionBody = ClassDefinitionBody::Empty();

    for (long k = (long)classDefinitionTerms.size() - 1; k >= 0; k--)
        classDefinitionBody = ClassDefinitionBody::Term(
            ClassDefinitionTermWithMetadata(
                classDefinitionTerms[k],
                CSTValue()
                ),
            classDefinitionBody
            );

    return Expression::CreateClass(
        className,
        ClassDefinition(
            classDefinitionBody,
            null() << Symbol(className),
            null() << Symbol("@self"),
            ExpressionLocationMetadata::WithSimpleParseRange(extent)
            ),
        CSTValue()
        );
    }

Expression PythonAstConverter::replaceUnconvertiblesWithThrowExprs(
        const Expression& e,
        const ImmutableTreeVector<Symbol>& unconvertibleSymbols
        ) const
    {
    ImmutableTreeMap<Symbol, Expression> remap;
    for (const auto& sym: unconvertibleSymbols)
        {
        remap = remap + std::make_pair(
            sym,
            checkVariableValidityExpression(sym)
            );
        }

    return rebindFreeAs(e, remap);
    }

Function PythonAstConverter::convertFunctionDefToForaFunction(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    TuplePattern tuplePattern =
        TuplePattern(
            emptyTreeVec() +
            TuplePatternElement::Normal(
                null() << Symbol("@unnamed_args"),
                PatternWithName::Anything(
                    null() << Symbol("@unnamed_args")
                    ),
                null()
                ) +
            TuplePatternElement::Normal(
                null() << Symbol("@named_args"),
                PatternWithName::Anything(
                    null() << Symbol("@named_args")
                    ),
                null()
                )
            );

    auto unpackedArguments =
        unpackArguments(
            functionDef.args(),
            extent,
            functionDef.name()
            );

    Expression functionBody = foraFunctionBodyForPythonFunctionDef(
        functionDef,
        extent
        );

    functionBody = Expression::Sequence(
        invalidPythonCallCheckExpr(functionDef),
        functionBody
        );

    if (unpackedArguments.size() > 0)
        functionBody = Expression::Let(
            unpackedArguments,
            functionBody
            );

    functionBody = initializeUnboundVariablesForFunction(
        tuplePattern,
        functionBody
        );

    if (hasYield(functionDef))
        functionBody =
            Expression::Call(
                Expression::Constant(mPyGeneratorFactory),
                emptyTreeVec() +
                    Expression::CreateFunction(
                        "<generator>",
                        Function::Term(
                            TuplePattern(),
                            functionBody,
                            Function::Empty()
                            ),
                        CSTValue()
                        ).normalApplyArg()
                );

    const std::string& inner_func_name = "@inner_func";
    const std::string& outer_func_args = "@func_args";

    Expression funcBody = Expression::Let(
        Symbol(inner_func_name),
        Expression::CreateFunction(
            inner_func_name,
            Function::Term(
                tuplePattern,
                functionBody,
                forwardNewCallingConventionToOldCallingConvention(
                    inner_func_name
                    )
                ),
            CSTValue()
            ),
        Expression::Call(
            Expression::Variable(inner_func_name),
            emptyTreeVec() +
            ApplyArgument::TupleCall(
                Expression::Variable(outer_func_args)
                )
            )
        );

    return Function::Term(
        TuplePattern(
            emptyTreeVec() +
            TuplePatternElement::VarArgs(
                null() << Symbol(outer_func_args)
                )
            ),
        funcBody,
        Function::Empty()
        );
    }

Function PythonAstConverter::forwardNewCallingConventionToOldCallingConvention(
        const std::string& funcName) const
    {
    // we keep this guy around because of the way we invoke
    // RemotePythonObject function calls from pyfora clients.
    // It's probably possbile to change the way those ComputationDefinitions
    // are formed, but I (Tom) don't know enough about ComputedValues
    // to do that.

    return Function::Term(
        TuplePattern(
            emptyTreeVec() +
            TuplePatternElement::VarArgs(null() << Symbol("@unnamed_args"))
            ),
        Expression::Call(
            Expression::Variable(Symbol(funcName)),
            emptyTreeVec() +
            ApplyArgument::Normal(
                null() << Symbol("@unnamed_args"),
                Expression::Variable("@unnamed_args")
                ) +
            ApplyArgument::Normal(
                null() << Symbol("@named_args"),
                Expression::CreateTuple(
                    ImmutableTreeVector<ApplyArgument>()
                    )
                )
            ),
        Function::Empty()
        );
    }

Expression PythonAstConverter::checkVariableValidityExpression(Symbol s) const
    {
    return Expression::Try(
        Expression::Sequence(
            Expression::Apply(
                Expression::Constant(CSTValue(Symbol("CheckValueIsPyforaInvalidVariableSymbol"))),
                emptyTreeVec() +
                    ApplyArgument::Normal(Expression::Variable(Symbol(s)))
                ),
            Expression::Variable(Symbol(s))
            ),
        Function::Term(
            TuplePattern(
                emptyTreeVec() +
                    TuplePatternElement::VarArgs(null())
                ),
            Expression::Constant(CSTValue(mPyObjectBaseMixin))
            .member(Symbol("__pyfora_invalid_variable_access__"))(
                Expression::Variable(Symbol(s)),
                Expression::Constant(CSTValue(Symbol(s)))
                ),
            Function::Empty()
            ),
        null(),
        false
        );
    }

Expression PythonAstConverter::invalidPythonCallCheckExpr(
        const PythonAstStatement_FunctionDefType& functionDef
        ) const
    {
    // After unpacking the arguments tuples in PythonAstConverter::unpackArguments,
    // we check if tuples leftover still have any elements. Since we're not
    // doing varargs or kwargs yet, these are error conditions.

    Expression unnamed_args_var = Expression::Variable(Symbol("@unnamed_args"));
    Expression named_args_var = Expression::Variable(Symbol("@named_args"));

    return Expression::Branch(
        Expression::Call(
            Expression::Constant(CSTValue(Symbol("size"))),
            emptyTreeVec() + unnamed_args_var.normalApplyArg()
            ),
        throwTypeErrorExpression(
            "call expression to function " +
            functionDef.name() + "()"
            " had too many unnamed arguments"
            ),
        null() << Expression::Branch(
            Expression::Call(
                Expression::Constant(CSTValue(Symbol("size"))),
                emptyTreeVec() + named_args_var.normalApplyArg()
                ),
            throwTypeErrorExpression(
                "call expression to function " +
                functionDef.name() + "()" +
                " had too many named arguments"
                ),
            null()
            )
        );
    }

std::pair<Expression, TuplePattern>
PythonAstConverter::convertFunctionDefToForaFunctionBodyAndPattern(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    Expression functionBody =
        foraFunctionBodyForPythonFunctionDef(functionDef, extent);

    const auto& args = functionDef.args();
    ImmutableTreeVector<TuplePatternElement> foraArgs = computeForaArgs(args);

    checkFunctionArgs(args, extent);

    TuplePattern pattern = TuplePattern(foraArgs);

    return std::make_pair(functionBody, pattern);
    }

Expression PythonAstConverter::foraFunctionBodyForPythonFunctionDef(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& functionName = functionDef.name();
    ImmutableTreeVector<PythonAstStatement> body = functionDef.body();

    ImmutableTreeVector<PythonAstExpr> decoratorList = functionDef.decorator_list();
    if (decoratorList.size() > 0) {
        throw PythonToForaConversionError(
            "don't know how to convert decorator lists for functions right now",
            extent
            );
        }

    return Expression::Sequence(
        convertPythonAstStatementsToExpression(body),
        Expression::Return(
            Expression::Constant(
                mConstantConverter->noneValue()
                )
            )
        );


    return Expression::Sequence(
        invalidPythonCallCheckExpr(functionDef),
        Expression::Sequence(
            convertPythonAstStatementsToExpression(body),
            Expression::Return(
                Expression::Constant(
                    mConstantConverter->noneValue()
                    )
                )
            )
        );
    }

ImmutableTreeVector<pair<PatternWithName, Expression>>
PythonAstConverter::unpackArguments(
        const PythonAstArguments& pyFunctionSignature,
        const SimpleParseRange& extent,
        const std::string& functionName
        ) const
    {
    /*
      here we take transform a py function signature, eg def (x, y, z=z_expr)
      and transform it, roughly, into the fora function:

      let f = fun(@unnamed_args:, @named_args:) {
          let x = if (size(@unnamed_args)) {
              let elt0 = @unnamed_args[0];
              @unnamed_args = @unnamed_args[1,];
              elt0
              }
          else {
              match (*@named_args) with (x:elt, *rest) {
                   @named_args = res
                   elt
                   }
               (...) {
                    throw TypeError("couldn't find a match for x'
                   }
              }
          let y = if (size(@unnamed_args)) {
              let elt0 = @unnamed_args[0];
              @unnamed_args = @unnamed_args[1,];
              elt0
              }
          else {
              match (*@named_args) with (y:elt, *rest) {
                   @named_args = res
                   elt
                   }
               (...) {
                    throw TypeError("couldn't find a match for y'
                   }
              }
          let z = if (size(@unnamed_args)) {
              let elt0 = @unnamed_args[0];
              @unnamed_args = @unnamed_args[1,];
              elt0
              }
          else {
              match (*@named_args) with (x:elt, *rest) {
                   @named_args = res
                   elt
                   }
               (...) {
                    z_expr
                   }
              }


          // rest of function body
          }

     */


    int32_t nDefaultArgs = pyFunctionSignature.defaults().size();
    int32_t nNonDefaultArgs = pyFunctionSignature.args().size() - nDefaultArgs;

    lassert(nNonDefaultArgs >= 0);

    // see https://docs.python.org/2/reference/compound_stmts.html#grammar-token-sublist
    // for what args can look like

    // first handle non-default args
    auto tr = unpackNonDefaultArgs(
        pyFunctionSignature.args().slice(0, nNonDefaultArgs),
        extent,
        functionName
        );

    // then handle default args
    tr = tr + unpackDefaultArgs(
            pyFunctionSignature.args().slice(nNonDefaultArgs),
            pyFunctionSignature.defaults(),
            extent,
            functionName
        );

    return tr;
    }

ImmutableTreeVector<pair<PatternWithName, Expression>>
PythonAstConverter::unpackNonDefaultArgs(
        const ImmutableTreeVector<PythonAstExpr>& nonDefaultArgs,
        const SimpleParseRange& extent,
        const std::string& functionName
        ) const
    {
    ImmutableTreeVector<pair<PatternWithName, Expression>> tr;

    Expression unnamed_args_var = Expression::Variable(Symbol("@unnamed_args"));
    Expression named_args_var = Expression::Variable(Symbol("@named_args"));

    Symbol stacktraceVar = Symbol("@stacktrace");
    for (const auto& nonDefaultArg: nonDefaultArgs) {
        Expression sizeExpr = Expression::Call(
            Expression::Constant(CSTValue(Symbol("size"))),
            emptyTreeVec() +
            ApplyArgument::Normal(unnamed_args_var)
            );

        Expression ifSizeExpr = Expression::Let(
            Symbol("elt0"),
            unnamed_args_var[0],
            Expression::Sequence(
                Expression::Assign(
                    PatternWithName::Anything(
                        null() << unnamed_args_var.getVariable().variable()
                        ),
                    Expression::GetItem(
                        unnamed_args_var,
                        emptyTreeVec() +
                        ApplyArgument::Normal(
                            Expression::Constant(CSTValue(1))
                            ) +
                        ApplyArgument::Normal(
                            Expression::Constant(CSTValue())
                            )
                        )
                    ),
                Expression::Variable(Symbol("elt0"))
                )
            );

        Expression ifSizeZeroExpr;

        if (nonDefaultArg.isName()) {
            ifSizeZeroExpr = Expression::Match(
                emptyTreeVec() +
                ApplyArgument::TupleCall(
                    named_args_var
                    ),
                Function::Term(
                    TuplePattern(
                        emptyTreeVec() +
                        TuplePatternElement::Normal(
                            null() << Symbol(nonDefaultArg.getName().id()),
                            PatternWithName::Anything(
                                null() << Symbol("matched_value")
                                ),
                            null()
                            ) +
                        TuplePatternElement::VarArgs(
                            null() << Symbol("remaining_named_args")
                            )
                        ),
                    Expression::Sequence(
                        Expression::Assign(
                            PatternWithName::Anything(
                                null() << named_args_var.getVariable().variable()
                                ),
                            Expression::Variable(Symbol("remaining_named_args"))
                            ),
                        Expression::Variable(Symbol("matched_value"))
                        ),
                    Function::Term(
                        TuplePattern(
                            emptyTreeVec() +
                            TuplePatternElement::VarArgs(null())
                            ),
                        throwTypeErrorExpression(
                            "couldn't match argument " +
                            nonDefaultArg.getName().id() +
                            " in call to function " +
                            functionName + "()"
                            ),
                        Function::Empty()
                        )
                    )
                );
            }
        else {
            ifSizeZeroExpr =
                throwTypeErrorExpression("keyword can't be an expression");
            }

        tr = tr + std::make_pair(
            convertPythonAstExpressionToPattern(nonDefaultArg),
            Expression::Branch(
                sizeExpr,
                ifSizeExpr,
                null() << ifSizeZeroExpr
                )
            );
        }

    return tr;
    }

ImmutableTreeVector<pair<PatternWithName, Expression>>
PythonAstConverter::unpackDefaultArgs(
        const ImmutableTreeVector<PythonAstExpr>& defaultArgs,
        const ImmutableTreeVector<PythonAstExpr>& defaultValues,
        const SimpleParseRange& extent,
        const std::string& functionName
        ) const
    {
    lassert(defaultArgs.size() == defaultValues.size());

    ImmutableTreeVector<pair<PatternWithName, Expression>> tr;

    Expression unnamed_args_var = Expression::Variable(Symbol("@unnamed_args"));
    Expression named_args_var = Expression::Variable(Symbol("@named_args"));

    Symbol stacktraceVar = Symbol("@stacktrace");

    for (uint32_t ix = 0; ix < defaultArgs.size(); ++ix) {
        const PythonAstExpr& defaultArg = defaultArgs[ix];

        Expression sizeExpr = Expression::Call(
            Expression::Constant(CSTValue(Symbol("size"))),
            emptyTreeVec() +
            ApplyArgument::Normal(unnamed_args_var)
            );

        Expression ifSizeExpr = Expression::Let(
            Symbol("elt0"),
            unnamed_args_var[0],
            Expression::Sequence(
                Expression::Assign(
                    PatternWithName::Anything(
                        null() << unnamed_args_var.getVariable().variable()
                        ),
                    Expression::GetItem(
                        unnamed_args_var,
                        emptyTreeVec() +
                        ApplyArgument::Normal(
                            Expression::Constant(CSTValue(1))
                            ) +
                        ApplyArgument::Normal(
                            Expression::Constant(CSTValue())
                            )
                        )
                    ),
                Expression::Variable(Symbol("elt0"))
                )
            );

        Expression ifSizeZeroExpr;

        if (defaultArg.isName()) {
            ifSizeZeroExpr = Expression::Match(
                emptyTreeVec() +
                ApplyArgument::TupleCall(
                    named_args_var
                    ),
                Function::Term(
                    TuplePattern(
                        emptyTreeVec() +
                        TuplePatternElement::Normal(
                            null() << Symbol(defaultArg.getName().id()),
                            PatternWithName::Anything(
                                null() << Symbol("matched_value")
                                ),
                            null()
                            ) +
                        TuplePatternElement::VarArgs(
                            null() << Symbol("remaining_named_args")
                            )
                        ),
                    Expression::Sequence(
                        Expression::Assign(
                            PatternWithName::Anything(
                                null() << named_args_var.getVariable().variable()
                                ),
                            Expression::Variable(Symbol("remaining_named_args"))
                            ),
                        Expression::Variable(Symbol("matched_value"))
                        ),
                    Function::Term(
                        TuplePattern(
                            emptyTreeVec() +
                            TuplePatternElement::VarArgs(null())
                            ),
                        convertPythonAstExpressionToFora(defaultValues[ix]),
                        Function::Empty()
                        )
                    )
                );
            }
        else {
            ifSizeZeroExpr =
                throwTypeErrorExpression(
                    "keyword can't be an expression"
                    );
            }

        tr = tr + std::make_pair(
            convertPythonAstExpressionToPattern(defaultArg),
            Expression::Branch(
                sizeExpr,
                ifSizeExpr,
                null() << ifSizeZeroExpr
                )
            );
        }

    return tr;
    }

Expression PythonAstConverter::addWithBlockReturnStatement(
                Expression expr,
                ImmutableTreeVector<std::string> assigned
                ) const
    {
    return Expression::Sequence(
        expr,
        Expression::Return(
            mPythonTupleConverter->createTupleExpression(
                Expression::CreateTuple(
                    emptyTreeVec() +
                    ApplyArgument::Normal(
                        null(),
                        getDictOfAssignedVariables(assigned)
                        ) +
                    ApplyArgument::Normal(
                        null(),
                        constantExpressionForImplVal(
                            constantConverter()->convertInt(0)
                            )
                        ) +
                    ApplyArgument::Normal(
                        null(),
                        constantExpressionForImplVal(
                            constantConverter()->convertInt(0)
                            )
                        )
                    )
                )
            )
        );
    }

Expression PythonAstConverter::convertPythonAstWithBlockFunctionDefToFora(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent,
        ImmutableTreeVector<std::string> varsToConsiderFree
        ) const
    {
    ImmutableTreeSet<Symbol> varsToConsiderFreeSet;

    for (const auto& v: varsToConsiderFree)
        varsToConsiderFreeSet = varsToConsiderFreeSet + Symbol(v);

    const std::string& functionName = functionDef.name();

    std::pair<Expression, TuplePattern> functionBodyAndPattern =
        convertFunctionDefToForaFunctionBodyAndPattern(
            functionDef,
            extent
            );

    ImmutableTreeVector<std::string> assigned;
    for (const auto& var: functionBodyAndPattern.first.assignedVariables())
        if (var.toString()[0] != '@')
            assigned = assigned + var.toString();

    @match Expression(functionBodyAndPattern.first)
        -| Sequence(inner, Return(Constant(shouldBeNone))) ->> {
            lassert(shouldBeNone == CSTValue(mConstantConverter->noneValue()));

            functionBodyAndPattern.first = inner;
            }

    Expression functionBody = functionBodyAndPattern.first;

    ImmutableTreeSet<Symbol> freeVarsToCheck = functionBody.freeVariables();

    for (const auto& s: freeVarsToCheck)
        if (!varsToConsiderFreeSet.contains(s))
            functionBody = rebindFreeAs(functionBody, emptyTreeMap() + s + checkVariableValidityExpression(s));

    functionBody = wrapWithBlockFunctionBodyInTryCatch(
        functionBody,
        assigned
        );

    functionBody =
        addWithBlockReturnStatement(functionBody, assigned);

    for (const auto& s: freeVarsToCheck)
        if (!varsToConsiderFreeSet.contains(s))
            functionBody = Expression::Let(
                s,
                Expression::Constant(CSTValue(Symbol("PyforaUninitializedVariable"))),
                functionBody
                );
            else
        if (functionBody.assignedVariables().contains(s))
            {
            //put a wrapper around 's' so that it can be assigned to in the interior scope
            Symbol sWrapper = freshVarname("wrapper_", mentionedVariables(functionBody) + s);

            functionBody = Expression::Let(
                sWrapper,
                Expression::Variable(s),
                Expression::Let(
                    s,
                    Expression::Variable(sWrapper),
                    functionBody
                    )
                );
            }

    Function function = Function::Term(
        functionBodyAndPattern.second,
        functionBody,
        Function::Empty()
        );

    return createObjectImplementingCallOperatorForFunction(
        function,
        functionName,
        null() << extent
        );
    }

Expression PythonAstConverter::getDictOfAssignedVariables(
        const ImmutableTreeVector<std::string>& assignedVariables
        ) const
    {
    ImmutableTreeVector<Expression> keys;
    ImmutableTreeVector<Expression> values;

    for (const auto& name: assignedVariables)
        {
        keys = keys + Expression::Constant(
            CSTValue(
                mConstantConverter->convertString(name)
                )
            );
        values = values + Expression::Variable(
            Symbol(name)
            );
        }

    return mPythonDictConverter->createDictExpr(
        keys,
        values
        );
    }

Expression PythonAstConverter::wrapWithBlockFunctionBodyInTryCatch(
        const Expression& functionBody,
        const ImmutableTreeVector<std::string>& assignedVariables
        ) const
    {
    Symbol catchVar = freshVarname(
        "exception_var",
        mentionedVariables(
            functionBody
            )
        );

    // TODO not dealing with intermediate assigned variables yet

    Symbol stacktraceVar = Symbol("@stacktrace");

    Function catchFun =
        Function::Term(
            TuplePattern(
                emptyTreeVec() +
                    TuplePatternElement::Normal(
                        null(),
                        PatternWithName(
                            Pattern::Anything(),
                            null() << catchVar,
                            null(),
                            ExpressionLocationMetadata::Empty()
                            ),
                        null()
                        )
                ),
            Expression::Return(
                mPythonTupleConverter->createTupleExpression(
                    Expression::CreateTuple(
                        emptyTreeVec() +
                        ApplyArgument::Normal(
                            null(),
                            getDictOfAssignedVariables(assignedVariables)
                            ) +
                        ApplyArgument::Normal(
                            null(),
                            Expression::Variable(
                                stacktraceVar
                                )
                            ) +
                        ApplyArgument::Normal(
                            null(),
                            Expression::Variable(catchVar)
                            )
                        )
                    )
                ),
            Function::Empty()
            );

    return Expression::Try(
        functionBody,
        catchFun,
        null() << stacktraceVar,
        false
        );
    }

Expression PythonAstConverter::convertPythonAstFunctionDefToFora(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    const std::string& functionName = functionDef.name();

    Function function = convertFunctionDefToForaFunction(
        functionDef,
        extent
        );

    return createObjectImplementingCallOperatorForFunction(
        function,
        functionName,
        null() << extent
        );
    }

Expression PythonAstConverter::createObjectImplementingCallOperatorForFunction(
        const Function& function,
        const std::string& functionName,
        Nullable<SimpleParseRange> extent
        ) const
    {
    return Expression::CreateObject(
        functionName,
        ObjectDefinition(
            ObjectDefinitionBody::Term(
                ObjectDefinitionTermWithMetadata(
                    ObjectDefinitionTerm::Call(
                        function
                        ),
                    CSTValue()
                    ),
                mPyObjectBaseMixin.type().isClass() ?
                    ObjectDefinitionBody::Term(
                        ObjectDefinitionTermWithMetadata(
                            ObjectDefinitionTerm::Mixin(
                                Expression::Constant(
                                    CSTValue(mPyObjectBaseMixin)
                                    )
                                ),
                            CSTValue()
                            ),
                        ObjectDefinitionBody::Empty()
                        )
                :   ObjectDefinitionBody::Empty()
                ),
            null() << Symbol(functionName),
            extent ?
                ExpressionLocationMetadata::WithSimpleParseRange(*extent)
            :   ExpressionLocationMetadata::Empty()
            ),
        CSTValue()
        );
    }


/*
Called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm which verifies
expected properties on `args`
*/
ImmutableTreeVector<ClassDefinitionTerm>
PythonAstConverter::convertPythonClassBodyStaticMethodFunctionDefToForaClassDefinitionTerms(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    PythonAstStatement_FunctionDefType functionDefWithoutDecorators = functionDef;
    functionDefWithoutDecorators.decorator_list() = emptyTreeVec();

    Function function =
        convertFunctionDefToForaFunction(
            functionDefWithoutDecorators,
            extent
            );

    return emptyTreeVec() +
        ClassDefinitionTerm::Static(
            noncapturingObjectMember(
                functionDef.name(),
                createObjectImplementingCallOperatorForFunction(
                    function,
                    functionDef.name(),
                    null() << extent
                    )
                )
            ) +
        ClassDefinitionTerm::ObjectTerm(
            noncapturingObjectMember(
                functionDef.name(),
                createObjectImplementingCallOperatorForFunction(
                    function,
                    functionDef.name(),
                    null() << extent
                    )
                )
            );
    }

/*
Called from convertPythonClassBodyFunctionDefToForaClassDefinitionTerm which verifies
expected properties on `args`
*/
ClassDefinitionTerm
PythonAstConverter::convertPythonClassBodyPropertyToForaClassDefinitionTerm(
        const PythonAstStatement_FunctionDefType& functionDef,
        const SimpleParseRange& extent
        ) const
    {
    PythonAstStatement_FunctionDefType functionDefWithoutDecorators = functionDef;
    functionDefWithoutDecorators.decorator_list() = emptyTreeVec();

    Function function =
        convertFunctionDefToForaFunction(
            functionDefWithoutDecorators,
            extent
            );

    return ClassDefinitionTerm::ObjectTerm(
        ObjectDefinitionTerm::Anything(
            Function::Term(
                TuplePattern(
                    emptyTreeVec() +
                        TuplePatternElement::Normal(
                            PatternWithName::Constant(CSTValue(Symbol("Member")))
                            ) +
                    TuplePatternElement::Normal(
                        PatternWithName::Constant(CSTValue(Symbol(functionDef.name())))
                        )
                    ),
                Expression::Call(
                    Expression::Call(
                        Expression::Constant(mPyBoundMethod),
                        emptyTreeVec() +
                        Expression::Variable(Symbol("@self")).normalApplyArg() +
                        Expression::CreateFunction(
                            "__property_fun",
                            function,
                            CSTValue()
                            ).normalApplyArg() +
                        Expression::Constant(
                            CSTValue(Symbol(functionDef.name()))
                            ).normalApplyArg()
                        ),
                    emptyTreeVec()
                    ),
                Function::Empty()
                )
            )
        );
    }


ImmutableTreeVector<TuplePatternElement> PythonAstConverter::computeForaArgs(
        const PythonAstArguments& pythonArgs
        ) const
    {
    ImmutableTreeVector<TuplePatternElement> foraArgs;

    int defaultArgCount = pythonArgs.defaults().size();
    int totalArgumentCount = pythonArgs.args().size();
    int nonDefaultArgCount = totalArgumentCount - defaultArgCount;
    for (long k = 0; k < nonDefaultArgCount; k++)
        foraArgs = foraArgs + TuplePatternElement::Normal(
            null(),
            convertPythonAstExpressionToPattern(pythonArgs.args()[k]),
            null()
            );
    int idx = 0;
    for (long k = nonDefaultArgCount; k < totalArgumentCount; k++)
        foraArgs = foraArgs + TuplePatternElement::Normal(
            null(),
            convertPythonAstExpressionToPattern(pythonArgs.args()[k]),
            null() << convertPythonAstExpressionToFora(pythonArgs.defaults()[idx++])
            );

    return foraArgs;
    }

Expression
PythonAstConverter::throwTypeErrorExpression(const std::string& message) const
    {
    return Expression::Throw(
        Expression::Call(
            Expression::Constant(mTypeError),
            emptyTreeVec() +
            Expression::Call(
                Expression::Constant(mPyString),
                emptyTreeVec() +
                Expression::Constant(CSTValue(message)).normalApplyArg()
                ).normalApplyArg()
            ),
        null()
        );
    }

}


